<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="golang的基本语法">
<meta property="og:type" content="article">
<meta property="og:title" content="golang基础教程">
<meta property="og:url" content="http://example.com/2021/08/15/golang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/index.html">
<meta property="og:site_name" content="WenYa Yu Blog">
<meta property="og:description" content="golang的基本语法">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gitee.com/yushen611/img/raw/master/image-20230316002007968.png">
<meta property="og:image" content="https://gitee.com/yushen611/img/raw/master/image-20230316002105627.png">
<meta property="og:image" content="https://gitee.com/yushen611/img/raw/master/image-20230316002044290.png">
<meta property="og:image" content="https://gitee.com/yushen611/img/raw/master/image-20230316002140305.png">
<meta property="og:image" content="https://gitee.com/yushen611/img/raw/master/image-20230315232405998.png">
<meta property="og:image" content="https://gitee.com/yushen611/img/raw/master/image-20230315230929017.png">
<meta property="og:image" content="https://gitee.com/yushen611/img/raw/master/640">
<meta property="og:image" content="https://gitee.com/yushen611/img/raw/master/image-20230317150608883.png">
<meta property="og:image" content="https://gitee.com/yushen611/img/raw/master/image-20230317155426309.png">
<meta property="og:image" content="https://gitee.com/yushen611/img/raw/master/image-20230318143813507.png">
<meta property="og:image" content="https://gitee.com/yushen611/img/raw/master/image-20230318203926697.png">
<meta property="og:image" content="https://gitee.com/yushen611/img/raw/master/image-20230318204057735.png">
<meta property="og:image" content="https://gitee.com/yushen611/img/raw/master/image-20230318204306210.png">
<meta property="og:image" content="https://gitee.com/yushen611/img/raw/master/image-20230318204631254.png">
<meta property="og:image" content="https://gitee.com/yushen611/img/raw/master/image-20230318204803501.png">
<meta property="og:image" content="https://gitee.com/yushen611/img/raw/master/image-20230318204939721.png">
<meta property="og:image" content="https://gitee.com/yushen611/img/raw/master/image-20230318205048675.png">
<meta property="og:image" content="https://gitee.com/yushen611/img/raw/master/image-20230318205210487.png">
<meta property="og:image" content="https://gitee.com/yushen611/img/raw/master/image-20230318205430210.png">
<meta property="og:image" content="https://gitee.com/yushen611/img/raw/master/image-20230318205548863.png">
<meta property="og:image" content="https://gitee.com/yushen611/img/raw/master/image-20230318205729936.png">
<meta property="og:image" content="https://gitee.com/yushen611/img/raw/master/image-20230318205915554.png">
<meta property="article:published_time" content="2021-08-15T00:15:16.000Z">
<meta property="article:modified_time" content="2023-05-08T04:41:22.217Z">
<meta property="article:author" content="WenYa Yu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/yushen611/img/raw/master/image-20230316002007968.png">

<link rel="canonical" href="http://example.com/2021/08/15/golang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>golang基础教程 | WenYa Yu Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">WenYa Yu Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">余文涯个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-research">

    <a href="/research/" rel="section"><i class="fa fa-book fa-fw"></i>Research</a>

  </li>
        <li class="menu-item menu-item-projects">

    <a href="/projects/" rel="section"><i class="fa fa-wrench fa-fw"></i>Projects</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/15/golang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/myPhoto.jpg">
      <meta itemprop="name" content="WenYa Yu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WenYa Yu Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          golang基础教程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-15 08:15:16" itemprop="dateCreated datePublished" datetime="2021-08-15T08:15:16+08:00">2021-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-05-08 12:41:22" itemprop="dateModified" datetime="2023-05-08T12:41:22+08:00">2023-05-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          
            <div class="post-description">golang的基本语法</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <meta name="referrer" content="no-referrer">



<h1 id="golang基础教程"><a href="#golang基础教程" class="headerlink" title="golang基础教程"></a>golang基础教程</h1><p>第一部分为：golang的基础语法：数据与方法，数据结构与算法、外部库的管理与使用、应用级编程。</p>
<p>第二部分为：golang的特性</p>
<p>第三部分为：golang的应用：golang与数据库的交互；golang的web请求；</p>
<p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/aceld/mo95lb/dsk886">8小时转职Golang工程师</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/golang101-1.19.e">Go语言101 - 《Go语言101 v1.19.e》 - 书栈网 · BookStack</a></p>
<p><a target="_blank" rel="noopener" href="https://books.studygolang.com/the-way-to-go_ZH_CN/">Introduction · Go入门指南 (studygolang.com)</a></p>
<h1 id="一、golang简介"><a href="#一、golang简介" class="headerlink" title="一、golang简介"></a>一、golang简介</h1><h2 id="go语言的优缺点"><a href="#go语言的优缺点" class="headerlink" title="go语言的优缺点"></a>go语言的优缺点</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p><img src="https://gitee.com/yushen611/img/raw/master/image-20230316002007968.png" alt="image-20230316002007968"></p>
<img src="https://gitee.com/yushen611/img/raw/master/image-20230316002105627.png" alt="image-20230316002105627" style="zoom:50%;">

<h3 id="适合方向"><a href="#适合方向" class="headerlink" title="适合方向"></a>适合方向</h3><p><img src="https://gitee.com/yushen611/img/raw/master/image-20230316002044290.png" alt="image-20230316002044290"></p>
<h3 id="可能缺点"><a href="#可能缺点" class="headerlink" title="可能缺点"></a>可能缺点</h3><p><img src="https://gitee.com/yushen611/img/raw/master/image-20230316002140305.png" alt="image-20230316002140305"></p>
<p>注：后引入了泛化类型</p>
<h2 id="go的安装"><a href="#go的安装" class="headerlink" title="go的安装"></a>go的安装</h2><h3 id="下载安装与检测环境变量"><a href="#下载安装与检测环境变量" class="headerlink" title="下载安装与检测环境变量"></a>下载安装与检测环境变量</h3><p>GOLANG官网:<a href="https://link.zhihu.com/?target=https://golang.google.cn/">https://golang.google.cn/</a></p>
<p>命令行输入<code>go version</code>，查看是否安装成功</p>
<p>Go开发相关的环境变量用<code>go env</code>命令查看</p>
<p><img src="https://gitee.com/yushen611/img/raw/master/image-20230315232405998.png" alt="image-20230315232405998"></p>
<h3 id="配置环境变量：GOPROXY"><a href="#配置环境变量：GOPROXY" class="headerlink" title="配置环境变量：GOPROXY"></a>配置环境变量：GOPROXY</h3><p>从字面意思就能看出，GOPROXY表示的是go的代理设置，之所以有这个环境变量，是因为go这种语言不像C语言，在C语言中，如果我们想要使用别人的第三方代码，一般有两种途径：<br>1、将第三方代码源码合并到自己的工程文件中，再合并编译。<br>2、将第三方代码编译生成的共享库***.so或*.dll** 文件放到工程目录下，然后通过条件编译来使用。</p>
<p>而在go语言中，类似于java，可以在编程时，引入第三方代码的库地址，比如git仓库，然后在编译的时候，IDE会自动的拉取第三方库文件到当前工程。</p>
<p>这样做虽然很方便，但是带来了一个问题：网速和限制，因为一些第三方代码库是在国外服务器上的，因为一些限制，我们不能很顺利的使用和下载这些仓库，这样就会导致下载缓慢或者失败，所以这个时候就需要一个 代理来实现下载，这个代理就是中间商，可以跨过限制来访问。</p>
<p>默认GoPROXY配置是：<code>GOPROXY=https://proxy.golang.org,direct</code>，<br>由于国内访问不到 <code>https://proxy.golang.org</code> 所以我们需要换一个<code>PROXY</code>，这里推荐使用<code>https://goproxy.io</code> 或 <code>https://goproxy.cn</code> 或者 <code>https://mirrors.aliyun.com/goproxy/</code>。</p>
<p>可以执行下面的命令修改<code>GOPROXY</code>：</p>
<p><code>go env -w GOPROXY=https://goproxy.cn,direct</code></p>
<h3 id="配置环境变量：GO111MODULE"><a href="#配置环境变量：GO111MODULE" class="headerlink" title="配置环境变量：GO111MODULE"></a>配置环境变量：GO111MODULE</h3><p>GO111MODULE 有三个值：off, on和auto（默认值）。</p>
<ul>
<li>GO111MODULE&#x3D;off，go命令行将不会支持module功能，寻找依赖包的方式将会沿用旧版本那种通过vendor目录或者GOPATH模式来查找。</li>
<li>GO111MODULE&#x3D;on，go命令行会使用modules，而一点也不会去GOPATH目录下查找。</li>
<li>GO111MODULE&#x3D;auto，默认值，go命令行将会根据当前目录来决定是否启用module功能。这种情况下可以分为两种情形：<br>当前目录在GOPATH&#x2F;src之外且该目录包含go.mod文件<br>当前文件在包含go.mod文件的目录下面。</li>
</ul>
<p>执行以下命令开启go mod管理</p>
<p><code>go env -w GO111MODULE=on</code></p>
<h3 id="查看环境变量：GOPATH-和-GOROOT"><a href="#查看环境变量：GOPATH-和-GOROOT" class="headerlink" title="查看环境变量：GOPATH 和 GOROOT"></a>查看环境变量：GOPATH 和 GOROOT</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38151401/article/details/105729884">https://blog.csdn.net/qq_38151401/article/details/105729884</a></p>
</blockquote>
<p>不同于其他语言，<strong>go中没有项目的说法</strong>，只有包, 其中有两个重要的路径，GOROOT 和 GOPATH</p>
<h4 id="GOROOT"><a href="#GOROOT" class="headerlink" title="GOROOT"></a>GOROOT</h4><p><strong>GOROOT</strong>：GOROOT就是Go的安装目录，（类似于java的JDK）</p>
<p>GOROOT是Go的安装路径。<u>GOROOT在绝大多数情况下都不需要修改</u></p>
<p><img src="https://gitee.com/yushen611/img/raw/master/image-20230315230929017.png" alt="image-20230315230929017"></p>
<h4 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h4><p><strong>GOPATH</strong>：GOPATH是我们的工作空间,保存go项目代码和第三方依赖包<br><strong>GOPATH</strong>可以设置多个，其中，第一个将会是默认的包目录，使用 go get 下载的包都会在第一个path中的src目录下，使用 go install时，在哪个GOPATH中找到了这个包，就会在哪个GOPATH下的bin目录生成可执行文件</p>
<p>GOPATH是开发时的工作目录。用于：</p>
<ol>
<li>保存编译后的二进制文件。</li>
<li><code>go get</code>和<code>go install</code>命令会下载go代码到GOPATH。</li>
<li>import包时的搜索路径</li>
</ol>
<p>使用GOPATH时，GO会在以下目录中搜索包：</p>
<ol>
<li><code>GOROOT/src</code>：该目录保存了Go标准库代码。</li>
<li><code>GOPATH/src</code>：该目录保存了应用自身的代码和第三方依赖的代码。</li>
</ol>
<p>假设程序中引入了如下的包：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;Go-Player/src/chapter17/models&quot;</span></span><br></pre></td></tr></table></figure>

<p>第一步：Go会先去<strong>GOROOT的scr目录</strong>中查找，很显然它不是标准库的包，没找到。<br>第二步：继续在<strong>GOPATH的src目录</strong>去找，准确说是<strong>GOPATH&#x2F;src&#x2F;Go-Player&#x2F;src&#x2F;chapter17&#x2F;models</strong>这个目录。如果该目录不存在，会报错找不到package。在使用GOPATH管理项目时，需要按照GO寻找package的规范来合理地保存和组织Go代码。</p>
<p><strong>注意！！！</strong></p>
<blockquote>
<p>Go1.14版本之后，都推荐使用<code>go mod</code>模式来管理依赖了，<strong>也不再强制我们把代码必须写在<code>GOPATH</code>下面的<code>src</code>目录了，你可以在你电脑的任意位置编写go代码。</strong></p>
</blockquote>
<h2 id="go的hello-world"><a href="#go的hello-world" class="headerlink" title="go的hello world"></a>go的hello world</h2><p>编写一个文件hello.go</p>
<h3 id="编写最简hello-world代码"><a href="#编写最简hello-world代码" class="headerlink" title="编写最简hello world代码"></a><strong>编写最简hello world代码</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">/* 简单的程序 万能的hello world */</span></span><br><span class="line">      fmt.Println(<span class="string">&quot;Hello Go&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第一行</strong>：<strong>package main</strong> 程序的第一行声明了名为main的package。<u>Go语言的代码是通过package来组织的</u>，package的概念和其他语言里的package，module概念类似，<strong>是一个逻辑的，包含了相同功能代码的集合</strong>。<strong>一个package会包含一个或多个.go源代码文件。每一个源文件都是以package开头。</strong>比如我们的例子里是package main。这行声明语句表示该文件是属于哪一个package。同时需要注意，一个程序的<code>main</code>入口函数必须不带任何输入参数和返回结果</p>
<p>需要注意，<u>package main是一个比较特殊的package</u>。<strong>main package是Go程序的入口</strong>。准确说，Go程序的入口是<u>名为main的package中的main方法</u>(即例子中的main方法)。</p>
<p><strong>第二行</strong>： import package声明语句后紧跟着是import语句。<strong>import语句会引入其他package到当前文件中，这样就可以在当前文件使用其他package中的变量，常量，类型，方法等</strong>。Go的import和Java的import，C++的include类似。Go标准库已经提供了100多个package，fmt这个package包含接受输入，格式化输出的各种函数。Println是其中的一个常用函数，可以格式化地输出一段文本。</p>
<p><strong>第三行</strong>： &#x3D;&#x3D;func main 第三行声明了一个函数&#x3D;&#x3D;，函数名为main。在Go语言中使用func关键字来声明一个函数。格式为:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(参数名1 参数类型1, 参数名2 参数类型2, ... )</span></span> (返回类型<span class="number">1</span>, 返回类型<span class="number">2</span>, ...)</span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(name <span class="type">string</span>, age <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure>

<p>声明了一个sayHello方法。接收两个参数：string类型的name和int类型的age。并返回一个string类型的值。前面也提到了，在main这个package里，main函数也是一个特殊的函数，这是整个程序的入口(其实C系语言差不多都是这样)。</p>
<p><strong>第四行</strong>： fmt.Println(…)可以将字符串输出到控制台，并在最后自动增加换行字符 \n。 使用 fmt.Print(“hello, world\n”) 可以得到相同的结果。 Print 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将 变量 arr 输出到控制台。</p>
<blockquote>
<p>其实也可以不用调用fmt包直接print(“hello world”) 或者 prntln(“hello world”) , 因为print是go的一个标识符了)</p>
</blockquote>
<h3 id="编写多包hello-world"><a href="#编写多包hello-world" class="headerlink" title="编写多包hello world"></a>编写多包hello world</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main <span class="comment">//程序的包名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">import &quot;fmt&quot;</span></span><br><span class="line"><span class="comment">import &quot;time&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; <span class="comment">//函数的&#123;  一定是 和函数名在同一行的，否则编译错误</span></span><br><span class="line">	<span class="comment">//golang中的表达式，加&quot;;&quot;, 和不加 都可以，建议是不加</span></span><br><span class="line">	fmt.Println(<span class="string">&quot; hello Go!&quot;</span>)</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="go语法特色总结"><a href="#go语法特色总结" class="headerlink" title="go语法特色总结"></a>go语法特色总结</h3><p>从hello world可以看出go的一些特点。</p>
<ol>
<li>main函数必须在main包里，main包里的某一个go文件必须包含main函数</li>
<li>import包的方式有两种，一种是多行import,如<code>import pkg1 </code>，另一种是<code>import (pkg1,pkg2,...)</code></li>
<li><strong>函数的定义关键词是func,返回值类型直接写在入参右括号的旁边，可以有多个返回值。函数体的第一个大括号必须跟函数名在同一行。</strong></li>
<li>加不加分号都可以，但是<strong>推荐不加分号</strong></li>
</ol>
<p>由于Hello world程序比较简单，其他特点也包括：</p>
<ol>
<li>Go语言不需要显示声明方法或变量的作用范围。即不用显式声明public或private。其实<u>Go语言是通过变量或方法名的首字母是大写还是小写来确定作用范围的</u>。<strong>大写字母开头的为public，小写字母开头的为private</strong>。</li>
<li>Go语言<strong>声明变量和方法参数时，名字在前，类型在后</strong>。比如<u>var name string</u>。这和C系语言，Java语言都不同。</li>
</ol>
<h2 id="go的常用命令"><a href="#go的常用命令" class="headerlink" title="go的常用命令"></a>go的常用命令</h2><h3 id="编译与运行"><a href="#编译与运行" class="headerlink" title="编译与运行"></a>编译与运行</h3><ol>
<li>go build 编译：编译成可执行文件</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build hello.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<p>用于测试编译包，在项目目录下生成可执行文件（有main包）。linux生成可执行文件，.&#x2F;可以直接运行；win生成.exe文件</p>
<ol start="2">
<li>go run编译加运行：编译后直接运行</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> run hello.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<p>go run子命令只是一种方便的方式来运行简单的Go程序。<br>对于正式的项目，最好使用go build或者go install子命令构建可执行程序文件来运行Go程序。</p>
<ol start="3">
<li>go install :主要用来生成库和工具。</li>
</ol>
<p>可以直接在某一文件夹下使用<code>go build</code>或者<code>go install</code></p>
<p>主要用来生成库和工具。一是编译包文件（无main包），将编译后的包文件放到 pkg 目录下（<code>$GOPATH/pkg</code>）。二是编译生成可执行文件（有main包），将可执行文件放到 bin 目录（<code>$GOPATH/bin</code>）。</p>
<blockquote>
<p>go build VS go install</p>
<ul>
<li>go build 不能生成包文件, go install 可以生成包文件</li>
<li>go build 生成可执行文件在当前目录下， go install 生成可执行文件在bin目录下（<code>$GOPATH/bin</code>）</li>
<li>相同点：都能生成可执行文件</li>
</ul>
</blockquote>
<h3 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a>查看环境变量</h3><figure class="highlight go"><figcaption><span>env</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> env</span><br></pre></td></tr></table></figure>

<p>查看GOPATH，GOROOT,GOPROIXY环境变量都可以使用该命令查看。</p>
<h3 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h3><p>运行go fmt进行格式化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> fmt</span><br></pre></td></tr></table></figure>



<h2 id="go的关键字与标识符简介"><a href="#go的关键字与标识符简介" class="headerlink" title="go的关键字与标识符简介"></a>go的关键字与标识符简介</h2><h3 id="go的25个关键字"><a href="#go的25个关键字" class="headerlink" title="go的25个关键字"></a>go的25个关键字</h3><p>关键字是一些特殊的用来帮助编译器理解和解析源代码的单词。</p>
<p>截至目前（Go 1.20），<strong>Go中共有25个关键字</strong>。</p>
<p>break     default      func    interface  selectcase      defer        go      map        structchan      else         goto    package    switchconst     fallthrough  if      range      typecontinue  for          import  return     var</p>
<p><strong>go的25个关键字可以分为4组：声明组，组合组，流程控制组，特殊组</strong></p>
<p>const、func、import、package、type和var用来声明各种代码元素。</p>
<p>chan、interface、map和struct用做<br>    一些组合类型的字面表示中。</p>
<p>break、case、continue、default、 else、fallthrough、for、 goto、if、range、 return、select和switch用在流程控制语句中。<br>    详见基本流程控制语法（第12章）。</p>
<p>defer和go也可以看作是流程控制关键字，<br>    但它们有一些特殊的作用。详见协程和延迟函数调用</p>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p><strong>标识符是用于命名的</strong>，即是指Go语言对各种变量、方法、函数等命名时使用的字符序列，标识符由若干个字母、下划线<code>_</code>、和数字组成，且第一个字符必须是字母。通俗的讲就是凡可以自己定义的名称都可以叫做标识符。</p>
<p><strong>空标识符</strong><code>_</code>是用于接受多返回值时，占位的</p>
<p><strong>标识符的访问权限</strong>：Go语言中的变量、函数、常量名称的首字母也可以大写，如果首字母大写，则表示它可以被其它的包访问（类似于 <a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a> 中的 public）；如果首字母小写，则表示它只能在本包中使用 (类似于 Java 中 private）。</p>
<p><strong>go语言的预定标识符</strong>：预定义标识符一共有 36 个，<strong>主要包含Go语言中的基础数据类型和内置函数</strong>，这些预定义标识符也不可以当做标识符来使用。</p>
<table>
<thead>
<tr>
<th>append</th>
<th>bool</th>
<th>byte</th>
<th>cap</th>
<th>close</th>
<th>complex</th>
<th>complex64</th>
<th>complex128</th>
<th>uint16</th>
</tr>
</thead>
<tbody><tr>
<td>copy</td>
<td>false</td>
<td>float32</td>
<td>float64</td>
<td>imag</td>
<td>int</td>
<td>int8</td>
<td>int16</td>
<td>uint32</td>
</tr>
<tr>
<td>int32</td>
<td>int64</td>
<td>iota</td>
<td>len</td>
<td>make</td>
<td>new</td>
<td>nil</td>
<td>panic</td>
<td>uint64</td>
</tr>
<tr>
<td>print</td>
<td>println</td>
<td>real</td>
<td>recover</td>
<td>string</td>
<td>true</td>
<td>uint</td>
<td>uint8</td>
<td>uintptr</td>
</tr>
</tbody></table>
<h1 id="二、数据与方法"><a href="#二、数据与方法" class="headerlink" title="二、数据与方法"></a>二、数据与方法</h1><p>主要包括：数据的类型，数据的定义，方法的定义，逻辑与控制</p>
<h2 id="数据的类型"><a href="#数据的类型" class="headerlink" title="数据的类型"></a>数据的类型</h2><h3 id="数据的基本类型"><a href="#数据的基本类型" class="headerlink" title="数据的基本类型"></a>数据的基本类型</h3><p>类型（type）可以被看作是值（value）的模板，值可以被看作是类型的实例。本段将介绍内置（或称为预声明的）基本类型和它们字面量的表示形式。本段不介绍组合类型。</p>
<h4 id="Go支持的内置基本类型"><a href="#Go支持的内置基本类型" class="headerlink" title="Go支持的内置基本类型"></a><strong>Go支持的内置基本类型</strong></h4><ul>
<li><p>一种内置布尔类型：bool。</p>
</li>
<li><p>11种内置整数类型：int8、uint8、int16、uint16、int32、uint32、int64、uint64、int、uint和uintptr。</p>
</li>
<li><p>两种内置浮点数类型：float32和float64。</p>
</li>
<li><p>两种内置复数类型：complex64和complex128。</p>
</li>
<li><p>一种内置字符串类型：string。</p>
</li>
</ul>
<p>我们可以不用引入任何代码包而直接使用这些内置基本类型。</p>
<p>除了bool和string类型，<u>其它的15种内置基本类型都称为数值类型</u>（整型、浮点数型和复数型）。</p>
<p><strong>Go中有两种内置类型别名</strong>（type alias）：</p>
<ul>
<li><p><strong>byte</strong>是uint8的内置别名。我们可以将byte和uint8看作是同一个类型。</p>
</li>
<li><p><strong>rune</strong>是int32的内置别名。我们可以将rune和int32看作是同一个类型。</p>
</li>
</ul>
<h4 id="内置基本类型的尺寸"><a href="#内置基本类型的尺寸" class="headerlink" title="内置基本类型的尺寸"></a><strong>内置基本类型的尺寸</strong></h4><p><u>以u开头的整数类型称为无符号整数类型</u>。无符号整数类型的值都是非负的。一个数值类型名称中的数字表示每个这个类型的值将在内存中占有多少二进制位（以后简称位）。二进制位常称为比特（bit）。比如，一个uint8的值将占有8位。我们称uint8类型的值的尺寸是8位。因此，最大的uint8值是255（28-1），而最大的int8值是127（27-1），最小的int8值是-128（-27）。</p>
<p>任一个类型的所有值的尺寸都是相同的，所以一个值的尺寸也常称为它的<u>类型的尺寸</u>。</p>
<p>更多的时候，我们使用<u>字节（byte）</u>做为值尺寸的度量单位。一个字节相当于8个比特。所以uint32类型的尺寸为4，即每个uint32值占用4个字节。</p>
<p><u>uintptr、int以及uint类型</u>的值的尺寸依赖于具体编译器实现。通常地，在64位的架构上，int和uint类型的值是64位的；在32位的架构上，它们是32位的。编译器必须保证uintptr类型的值的尺寸能够存下任意一个内存地址。</p>
<p>一个<u>complex64</u>复数值的实部和虚部都是float32类型的值。一个<u>complex128</u>复数值的实部和虚部都是float64类型的值。</p>
<p>从逻辑上说，一个<u>字符串</u>值表示一段文本。在内存中，一个字符串存储为一个字节（byte）序列。此字节序列体现了此字符串所表示的文本的UTF-8编码形式。</p>
<h4 id="内置基本类型的零值"><a href="#内置基本类型的零值" class="headerlink" title="内置基本类型的零值"></a>内置基本类型的零值</h4><p>每种类型都有一个零值。一个类型的零值可以看作是此类型的默认值。</p>
<ul>
<li>一个布尔类型的零值表示真假中的假。</li>
<li>数值类型的零值都是零（但是不同类型的零在内存中占用的空间可能不同）。</li>
<li>一个字符串类型的零值是一个空字符串。</li>
</ul>
<h4 id="基本类型的字面量表示形式"><a href="#基本类型的字面量表示形式" class="headerlink" title="基本类型的字面量表示形式"></a>基本类型的字面量表示形式</h4><p>一个值的字面形式称为一个字面量，它表示此值在代码中文字体现形式（和内存中的表现形式相对应）。一个值可能会有很多种字面量形式。</p>
<p>参考：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/Golang101-v1.16.a-1/basic-types-and-value-literals.html">Go编程入门 - 基本类型和它们的字面量表示 - 《Go语言101 v1.16.a-1》 - 书栈网 · BookStack</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cheyunhua/p/16007219.html">详解 Go 中的 rune 类型 - 技术颜良 - 博客园 (cnblogs.com)</a></p>
</blockquote>
<ul>
<li><p><strong>布尔值的字面量形式</strong>：false和true</p>
</li>
<li><p><strong>整数类型值的字面量形式</strong></p>
<p><u>整数类型值有四种字面量形式</u>：十进制形式（decimal）、八进制形式（octal）、十六进制形式（hex）和二进制形式（binary）</p>
<p>比如，下面的三个字面量均表示十进制的15：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xF</span> <span class="comment">// 十六进制表示（必须使用0x或者0X开头）</span></span><br><span class="line"><span class="number">0XF</span></span><br><span class="line"></span><br><span class="line"><span class="number">017</span> <span class="comment">// 八进制表示（必须使用0、0o或者0O开头）</span></span><br><span class="line"><span class="number">0</span>o17</span><br><span class="line"><span class="number">0</span>O17</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>b1111 <span class="comment">// 二进制表示（必须使用0b或者0B开头）</span></span><br><span class="line"><span class="number">0</span>B1111</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>  <span class="comment">// 十进制表示（必须不能用0开头）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>浮点数类型值的字面量形式</strong></p>
<p>一个浮点数的完整字面量形式包含一个十进制整数部分、一个小数点、一个十进制小数部分和一个整数指数部分。 常常地，某些部分可以根据情况省略掉。一些例子（<code>xEn</code>表示<code>x</code>乘以<code>10n</code>的意思，而<code>xE-n</code>表示<code>x</code>除以<code>10n</code>的意思）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.23</span></span><br><span class="line"><span class="number">01.23</span> <span class="comment">// == 1.23</span></span><br><span class="line"><span class="number">.23</span></span><br><span class="line"><span class="number">1.</span></span><br><span class="line"><span class="comment">// 一个e或者E随后的数值是指数值（底数为10）。</span></span><br><span class="line"><span class="comment">// 指数值必须为一个可以带符号的十进制整数字面量。</span></span><br><span class="line"><span class="number">1.23e2</span>  <span class="comment">// == 123.0</span></span><br><span class="line"><span class="number">123E2</span>   <span class="comment">// == 12300.0</span></span><br><span class="line"><span class="number">123.E+2</span> <span class="comment">// == 12300.0</span></span><br><span class="line"><span class="number">1e-1</span>    <span class="comment">// == 0.1</span></span><br><span class="line"><span class="number">.1e0</span>    <span class="comment">// == 0.1</span></span><br><span class="line"><span class="number">0010e-2</span> <span class="comment">// == 0.1</span></span><br><span class="line"><span class="number">0e+5</span>    <span class="comment">// == 0.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>rune的字面量形式</strong></p>
<p><strong>rune的概念介绍</strong></p>
<p>rune是int32的别名，&#x3D;&#x3D;它是用来区分字符值和整数值（重点）&#x3D;&#x3D;。使用单引号定义 ，返回采用 UTF-8 编码的 Unicode 码点。Go 语言通过 <code>rune</code> 处理中文，支持国际化多语言。</p>
<p>Go 语言把字符分 <code>byte</code> 和 <code>rune</code> 两种类型处理。<code>byte</code> 是类型 <code>unit8</code> 的别名，用于存放占 1 字节的 ASCII 字符，如英文字符，返回的是字符原始字节。<code>rune</code> 是类型 <code>int32</code> 的别名，用于存放多字节字符，如占 3 字节的中文字符，返回的是字符 Unicode 码点值。如下图所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;Go语言编程&quot;</span></span><br><span class="line"><span class="comment">// byte</span></span><br><span class="line">fmt.Println([]<span class="type">byte</span>(s)) <span class="comment">// 输出：[71 111 232 175 173 232 168 128 231 188 150 231 168 139]</span></span><br><span class="line"><span class="comment">// rune</span></span><br><span class="line">fmt.Println([]<span class="type">rune</span>(s)) <span class="comment">// 输出：[71 111 35821 35328 32534 31243]</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/yushen611/img/raw/master/640" alt="图片"></p>
<blockquote>
<p>在我看来，<code>rune</code> 类型只是一种名称叫法，表示用来处理长度大于 1 字节（ 8 位）、不超过 4 字节（ 32 位）的字符类型。但万变不离其宗，我们使用函数时，无论传入参数的是原始字符串还是 <code>rune</code>，最终都是对字节进行处理。看似陌生的事物，沉下心了解到其本质以后，才发现原来并不陌生，缺少的只是正视它的勇气！</p>
</blockquote>
<p><strong>rune的表示(Unicode码点值的表示)</strong></p>
<p>在Go中，一个rune值表示一个Unicode码点。 一般说来，我们可以将一个Unicode码点看作是一个Unicode字符。 但是，我们也应该知道，有些Unicode字符由多个Unicode码点组成。 每个英文或中文Unicode字符值含有一个Unicode码点。</p>
<p>一个rune字面量由若干包在一对单引号中的字符组成。 包在单引号中的字符序列表示一个Unicode码点值。 rune字面量形式有几个变种，其中最常用的一种变种是<u>将一个rune值对应的Unicode字符直接包在一对单引号</u>中。比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span> <span class="comment">// 一个英文字符</span></span><br><span class="line"><span class="string">&#x27;π&#x27;</span></span><br><span class="line"><span class="string">&#x27;众&#x27;</span> <span class="comment">// 一个中文字符</span></span><br></pre></td></tr></table></figure>

<p>下面这些rune字面量形式的变种和<code>&#39;a&#39;</code>是等价的 （字符<code>a</code>的Unicode值是97）。(事实上，在日常编程中，这四种rune字面量形式的变种很少用来表示rune值。 它们多用做字符串的双引号字面量形式中的转义字符)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;\141&#x27;</span>   <span class="comment">// 141是97的八进制，表示一个byte值</span></span><br><span class="line"><span class="string">&#x27;\x61&#x27;</span>   <span class="comment">// 61是97的十六进制，表示一个byte值</span></span><br><span class="line"><span class="string">&#x27;\u0061&#x27;</span> <span class="comment">//0061是97的十六进制，表示一个rune值(Unicode码点值)</span></span><br><span class="line"><span class="string">&#x27;\U00000061&#x27;</span><span class="comment">//00000061是97的十六进制，表示一个rune值(Unicode码点值)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<code>\</code>之后必须跟随三个八进制数字字符（0-7）表示一个byte值， <code>\x</code>之后必须跟随两个十六进制数字字符（0-9，a-f和A-F）表示一个byte值， <code>\u</code>之后必须跟随四个十六进制数字字符表示一个rune值（此rune值的高四位都为0）， <code>\U</code>之后必须跟随八个十六进制数字字符表示一个rune值。 这些八进制和十六进制的数字字符序列表示的整数必须是一个合法的Unicode码点值，否则编译将失败。</p>
</blockquote>
<p>转义字符。如果一个rune字面量中被单引号包起来的部分含有两个字符， 并且第一个字符是<code>\</code>，第二个字符不是<code>x</code>、 <code>u</code>和<code>U</code>，那么这两个字符将被转义为一个特殊字符。 目前支持的转义组合为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\a   (<span class="type">rune</span>值：<span class="number">0x07</span>) 铃声字符</span><br><span class="line">\b   (<span class="type">rune</span>值：<span class="number">0x08</span>) 退格字符（backspace）</span><br><span class="line">\f   (<span class="type">rune</span>值：<span class="number">0x0C</span>) 换页符（form feed）</span><br><span class="line">\n   (<span class="type">rune</span>值：<span class="number">0x0A</span>) 换行符（line feed or newline）</span><br><span class="line">\r   (<span class="type">rune</span>值：<span class="number">0x0D</span>) 回车符（carriage <span class="keyword">return</span>）</span><br><span class="line">\t   (<span class="type">rune</span>值：<span class="number">0x09</span>) 水平制表符（horizontal tab）</span><br><span class="line">\v   (<span class="type">rune</span>值：<span class="number">0x0b</span>) 竖直制表符（vertical tab）</span><br><span class="line">\\   (<span class="type">rune</span>值：<span class="number">0x5c</span>) 一个反斜杠（backslash）</span><br><span class="line">\<span class="string">&#x27;   (rune值：0x27) 一个单引号（single quote）</span></span><br></pre></td></tr></table></figure>

<p>rune类型的零值常用 <code>&#39;\000&#39;</code>、<code>&#39;\x00&#39;</code>或<code>&#39;\u0000&#39;</code>等来表示。</p>
</li>
<li><p><strong>字符串值的字面量形式</strong></p>
<p>在Go中，字符串值是<strong>UTF-8</strong>编码的， 甚至所有的Go源代码都必须是UTF-8编码的。</p>
<p>这里有一个坑，关于<strong>utf-8编码</strong>。我们来看下面这个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;hello 世界&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(str))</span><br></pre></td></tr></table></figure>

<p>按照我们的设想，它返回的应该是8，但是实际上我们这么操作会得到12。原因很简单，因为在utf-8编码当中，一个<strong>汉字需要3个字节</strong>编码。那如果我们想要得到字符串本身的长度，而不是字符串占据的字节数，应该怎么办呢？这个时候，我们需要用到一个新的结构叫做rune，它表示单个Unicode字符。</p>
<p>所以我们可以将string转化成rune数组，之后再来<u>计算长度</u>，得到的结果就准确了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;hello 世界&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>([]<span class="type">rune</span>(str)))</span><br></pre></td></tr></table></figure>

<p>同样对于<u>截取字符串</u>也可以用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;Go语言编程&quot;</span></span><br><span class="line"><span class="comment">// 转成 rune 数组，需要几个字符，取几个字符</span></span><br><span class="line">fmt.Println(<span class="type">string</span>([]<span class="type">rune</span>(s)[:<span class="number">4</span>])) <span class="comment">// 输出：Go语言    </span></span><br></pre></td></tr></table></figure>



<p>Go字符串的字面量形式有两种。 一种是<strong>解释型字面表示</strong>（interpreted string literal，双引号风格）。 另一种是<strong>直白字面表示</strong>（raw string literal，反引号风格）。 下面的两个字符串表示形式是等价的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解释形式</span></span><br><span class="line"><span class="string">&quot;Hello\nworld!\n\&quot;你好世界\&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直白形式</span></span><br><span class="line"><span class="string">`Hello</span></span><br><span class="line"><span class="string">world!</span></span><br><span class="line"><span class="string">&quot;你好世界&quot;`</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="类型的显式类型转换"><a href="#类型的显式类型转换" class="headerlink" title="类型的显式类型转换"></a>类型的显式类型转换</h3><h4 id="类型不确定值"><a href="#类型不确定值" class="headerlink" title="类型不确定值"></a>类型不确定值</h4><p>​	在Go中，有些值的类型是不确定的。换句话说，有些值的类型有很多可能性。 这些值称为类型不确定值。对于<strong>大多数类型不确定值来说，它们各自都有一个默认类型</strong>， 除了预声明的<code>nil</code>。<code>nil</code>是没有默认类型的。 与类型不确定值相对应的概念称为类型确定值。</p>
<p>一个字面（常）量的默认类型取决于它为何种字面量形式：</p>
<ul>
<li>一个字符串字面量的默认类型是预声明的<code>string</code>类型。</li>
<li>一个布尔字面量的默认类型是预声明的<code>bool</code>类型。</li>
<li>一个整数型字面量的默认类型是预声明的<code>int</code>类型。</li>
<li>一个rune字面量的默认类型是预声明的<code>rune</code>（亦即<code>int32</code>）类型。</li>
<li>一个浮点数字面量的默认类型是预声明的<code>float64</code>类型。</li>
<li>如果一个字面量含有虚部字面量，则此字面量的默认类型是预声明的<code>complex128</code>类型。</li>
</ul>
<h4 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h4><p>和很多语言一样，Go也支持类型转换。 一个显式类型转换的形式为<code>T(v)</code>，其表示将一个值<code>v</code>转换为类型<code>T</code>。 编译器将<code>T(v)</code>的转换结果视为一个类型为<code>T</code>的类型确定值。 当然，对于一个特定的类型<code>T</code>，<code>T(v)</code>并非对任意的值<code>v</code>都合法。</p>
<ol>
<li><p><code>v</code><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/Golang101-v1.16.a-1/basic-types-and-value-literals.html#representability">可以表示为</a><code>T</code>类型的一个值。 转换结果为一个类型为<code>T</code>的类型确定常量值。</p>
</li>
<li><p><code>v</code>的默认类型是一个整数类型（<code>int</code>或者<code>rune</code>） 并且<code>T</code>是一个字符串类型。</p>
<blockquote>
<p>对于2：转换<code>T(v)</code>将<code>v</code>看作是一个Unicode码点。 转换结果为一个类型为<code>T</code>的字符串常量。 此字符串常量只包含一个Unicode码点，并且可以看作是此Unicode码点的UTF-8表示形式。 对于不在合法的Unicode码点取值范围内的整数<code>v</code>， 转换结果等同于字符串字面量<code>&quot;\uFFFD&quot;</code>（亦即<code>&quot;\xef\xbf\xbd&quot;</code>）。 <code>0xFFFD</code>是Unicode标准中的（非法码点的）替换字符值。 （但是请注意，今后的Go版本可能<a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/3939">只允许rune或者byte整数被转换为字符串</a>。 从Go官方工具链1.15版本开始，<code>go vet</code>命令会对从非rune和非byte整数到字符串的转换做出警告。）</p>
</blockquote>
</li>
</ol>
<p>事实上，第二种情形并不要求<code>v</code>必须是一个常量。 如果<code>v</code>是一个常量，则转换结果也是一个常量。 如果<code>v</code>不是一个常量，则转换结果也不是一个常量。</p>
<p>一些合法的转换例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果为complex128类型的1.0+0.0i。虚部被舍入了。</span></span><br><span class="line"><span class="type">complex128</span>(<span class="number">1</span> + <span class="number">-1e-1000i</span>)</span><br><span class="line"><span class="comment">// 结果为float32类型的0.5。这里也舍入了。</span></span><br><span class="line"><span class="type">float32</span>(<span class="number">0.49999999</span>)</span><br><span class="line"><span class="comment">// 只要目标类型不是整数类型，舍入都是允许的。</span></span><br><span class="line"><span class="type">float32</span>(<span class="number">17000000000000000</span>)</span><br><span class="line"><span class="type">float32</span>(<span class="number">123</span>)</span><br><span class="line"><span class="type">uint</span>(<span class="number">1.0</span>)</span><br><span class="line"><span class="type">int8</span>(<span class="number">-123</span>)</span><br><span class="line"><span class="type">int16</span>(<span class="number">6</span>+<span class="number">0i</span>)</span><br><span class="line"><span class="type">complex128</span>(<span class="number">789</span>)</span><br><span class="line"><span class="type">string</span>(<span class="number">65</span>)          <span class="comment">// &quot;A&quot;</span></span><br><span class="line"><span class="type">string</span>(<span class="string">&#x27;A&#x27;</span>)         <span class="comment">// &quot;A&quot;</span></span><br><span class="line"><span class="type">string</span>(<span class="string">&#x27;\u68ee&#x27;</span>)    <span class="comment">// &quot;森&quot;</span></span><br><span class="line"><span class="type">string</span>(<span class="number">-1</span>)          <span class="comment">// &quot;\uFFFD&quot;</span></span><br><span class="line"><span class="type">string</span>(<span class="number">0xFFFD</span>)      <span class="comment">// &quot;\uFFFD&quot;</span></span><br><span class="line"><span class="type">string</span>(<span class="number">0x2FFFFFFFF</span>) <span class="comment">// &quot;\uFFFD&quot;</span></span><br></pre></td></tr></table></figure>

<p>一些非法的转换：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>(<span class="number">1.23</span>)     <span class="comment">// 1.23不能被表示为int类型值。</span></span><br><span class="line"><span class="type">uint8</span>(<span class="number">-1</span>)     <span class="comment">// -1不能被表示为uint8类型值。</span></span><br><span class="line"><span class="type">float64</span>(<span class="number">1</span>+<span class="number">2i</span>) <span class="comment">// 1+2i不能被表示为float64类型值。</span></span><br><span class="line"><span class="comment">// -1e+1000不能被表示为float64类型值。不允许溢出。</span></span><br><span class="line"><span class="type">float64</span>(<span class="number">-1e1000</span>)</span><br><span class="line"><span class="comment">// 0x10000000000000000做为int值将溢出。</span></span><br><span class="line"><span class="type">int</span>(<span class="number">0x10000000000000000</span>)</span><br><span class="line"><span class="comment">// 字面量65.0的默认类型是float64（不是一个整数类型）。</span></span><br><span class="line"><span class="type">string</span>(<span class="number">65.0</span>)</span><br><span class="line"><span class="comment">// 66+0i的默认类型是complex128（不是一个整数类型）。</span></span><br><span class="line"><span class="type">string</span>(<span class="number">66</span>+<span class="number">0i</span>)</span><br></pre></td></tr></table></figure>

<p>注意，有时一个显式转换形式必须被写成<code>(T)(v)</code>以免发生歧义。 这种情况多发生在<code>T</code>不为一个标识符的时候。</p>
<h3 id="数据运算符"><a href="#数据运算符" class="headerlink" title="数据运算符"></a>数据运算符</h3><p><strong>五个基本二元算术运算符</strong>：加减乘除取余</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ - * / %</span><br></pre></td></tr></table></figure>

<p><strong>六种位运算符</strong>（也属于算术运算）: 位与 位或 异或 清位 左移位 右移位</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp; | ^ &amp;^ &lt;&lt; &gt;&gt;</span><br></pre></td></tr></table></figure>

<p>Go也支持<strong>三个一元算术运算符</strong>：</p>
<table>
<thead>
<tr>
<th align="left">字面形式</th>
<th align="left">名称</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">取正数</td>
<td align="left"><code>+n</code>等价于<code>0 + n</code>.</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">取负数</td>
<td align="left"><code>-n</code>等价于<code>0 - n</code>.</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">位反（或位补）</td>
<td align="left"><code>^n</code>等价于<code>m ^ n</code>，其中<code>m</code>和<code>n</code>同类型并且它的二进制表示中所有比特位均为1。 比如如果<code>n</code>的类型为<code>int8</code>，则<code>m</code>的值为<code>-1</code>；如果<code>n</code>的类型为<code>uint8</code>，则<code>m</code>的值为<code>255</code>。</td>
</tr>
</tbody></table>
<p>注意：</p>
<ul>
<li>在很多其它流行语言中，位反运算符是用<code>~</code>表示的。</li>
<li>和一些其它流行语言一样，加号运算符<code>+</code>也可用做字符串衔接运算符（见下）。</li>
<li>和C及C++语言一样，<code>*</code>除了可以当作乘号运算符，它也可以用做指针解引用运算符； <code>&amp;</code>除了可以当作位与运算符，它也可以用做取地址运算符。 后面的<a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/Golang101-v1.16.a-1/pointer.html">指针</a>一文将详解内存地址和指针类型。</li>
<li>和Java不一样，Go支持无符号数，所以Go不需要无符号右移运算符<code>&gt;&gt;&gt;</code>。</li>
<li>Go不支持幂运算符， 我们必须使用<code>math</code>标准库包中的<code>Pow</code>函数来进行幂运算。 下一篇文章将详解<a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/Golang101-v1.16.a-1/packages-and-imports.html">包和包引入</a>。</li>
<li>清位运算符<code>&amp;^</code>是Go中特有的一个运算符。 <code>m &amp;^ n</code>等价于<code>m &amp; (^n)</code>。</li>
</ul>
<p><strong><code>op=</code>运算符</strong></p>
<p>对于一个二元算数运算符<code>op</code>，语句<code>x = x op y</code>可以被简写为<code>x op= y</code>。 在这个简写的语句中，<code>x</code>只会被估值一次。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="type">int8</span> = <span class="number">3</span>, <span class="number">5</span></span><br><span class="line">a += b</span><br><span class="line"><span class="built_in">println</span>(a) <span class="comment">// 8</span></span><br><span class="line">a *= a</span><br><span class="line"><span class="built_in">println</span>(a) <span class="comment">// 64</span></span><br><span class="line">a /= b</span><br><span class="line"><span class="built_in">println</span>(a) <span class="comment">// 12</span></span><br><span class="line">a %= b</span><br><span class="line"><span class="built_in">println</span>(a) <span class="comment">// 2</span></span><br><span class="line">b &lt;&lt;= <span class="type">uint</span>(a)</span><br><span class="line"><span class="built_in">println</span>(b) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<p><strong>自增和自减操作符</strong></p>
<p>和很多其它流行语言一样，Go也支持自增（<code>++</code>）和自减（<code>--</code>）操作符。 不过和其它语言不一样的是，<strong>自增（<code>aNumber++</code>）和自减（<code>aNumber--</code>）操作操作没有返回值</strong>， 所以它们不能当做<a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/Golang101-v1.16.a-1/expressions-and-statements.html">表达式</a>来使用。 另一个显著区别是，在Go中，自增（<code>++</code>）和自减（<code>--</code>）<strong>操作符只能后置，不能前置</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b, c := <span class="number">12</span>, <span class="number">1.2</span>, <span class="number">1</span>+<span class="number">2i</span></span><br><span class="line">    a++ <span class="comment">// ok. &lt;=&gt; a += 1 &lt;=&gt; a = a + 1</span></span><br><span class="line">    b-- <span class="comment">// ok. &lt;=&gt; b -= 1 &lt;=&gt; b = b - 1</span></span><br><span class="line">    c++ <span class="comment">// ok.</span></span><br><span class="line">    <span class="comment">// 下面这些行编译不通过。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    _ = a++</span></span><br><span class="line"><span class="comment">    _ = b--</span></span><br><span class="line"><span class="comment">    _ = c++</span></span><br><span class="line"><span class="comment">    ++a</span></span><br><span class="line"><span class="comment">    --b</span></span><br><span class="line"><span class="comment">    ++c</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>字符串衔接运算符</strong></p>
<table>
<thead>
<tr>
<th align="left">字面形式</th>
<th align="left">名称</th>
<th align="left">对两个操作数的要求</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">字符串衔接</td>
<td align="left">两个操作数必须为同一类型的字符串值。</td>
</tr>
</tbody></table>
<p><code>+=</code>运算符也适用于字符串衔接。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println</span>(<span class="string">&quot;Go&quot;</span> + <span class="string">&quot;lang&quot;</span>) <span class="comment">// Golang</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;Go&quot;</span></span><br><span class="line">a += <span class="string">&quot;lang&quot;</span></span><br><span class="line"><span class="built_in">println</span>(a) <span class="comment">// Golang</span></span><br></pre></td></tr></table></figure>

<p><strong>布尔（又称逻辑）运算符</strong></p>
<table>
<thead>
<tr>
<th align="left">字面形式</th>
<th align="left">名称</th>
<th align="left">对操作值的要求</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;&amp;</td>
<td align="left">布尔与（二元）</td>
<td align="left">两个操作值的类型必须为同一布尔类型。</td>
</tr>
<tr>
<td align="left">||</td>
<td align="left">布尔或（二元）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">!</td>
<td align="left">布尔否（一元）</td>
<td align="left">唯一的一个操作值的类型必须为一个布尔类型。</td>
</tr>
</tbody></table>
<p><strong>比较运算符</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">== != &gt; &gt;= &lt; &lt;= </span><br></pre></td></tr></table></figure>

<ol>
<li>对于<code>==</code>与<code>!=</code>:</li>
</ol>
<ul>
<li>如果两个操作数都为类型确定的，则它们的类型必须一样，或者其中一个操作数可以隐式转换为另一个操作数的类型。 两者的类型必须都为可比较类型（将在以后的文章中介绍）。</li>
<li>如果只有一个操作数是类型确定的，则另一个类型不确定操作数必须可以隐式转换到类型确定操作数的类型。</li>
<li>如果两个操作数都是类型不确定的，则它们必须同时为两个类型不确定布尔值、两个类型不确定字符串值或者另个类型不确定数字值。</li>
</ul>
<ol start="2">
<li>对于其他<code>&gt; &gt;= &lt; &lt;=</code>：两个操作值的类型必须相同并且它们的类型必须为整数类型、浮点数类型或者字符串类型</li>
</ol>
<p>注意：</p>
<blockquote>
<p>以后，如果我们说两个值可以比较，我们的意思是说这两个值可以用<code>==</code>或者<code>!=</code>运算符来比较。 我们将在以后的文章中，我们将了解到某些类型的值是不能比较的。</p>
<p>注意，并非所有的实数在内存中都可以被精确地表示，所以比较两个浮点数或者复数的结果并不是很可靠。 在编程中，我们常常比较两个浮点数的差值是否小于一个阙值来检查两个浮点数是否相等。</p>
</blockquote>
<p><strong>展开运算符</strong></p>
<p>在 Go 语言中，展开运算符（…）主要<strong>用于函数的参数传递和数组&#x2F;切片的操作</strong>。</p>
<p>对于函数的参数传递，展开运算符可以将一个可迭代对象中的元素，逐个传递给函数作为参数。这种方式可以帮助我们简化代码，也提高了代码的灵活性和可读性。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">(args ...<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, arg := <span class="keyword">range</span> args &#123;</span><br><span class="line">        fmt.Println(arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFunc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 输出：1 2 3</span></span><br><span class="line"></span><br><span class="line">mySlice := []<span class="type">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">myFunc(mySlice...) <span class="comment">// 输出：4 5 6</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们定义了一个函数 myFunc，它可以接收任意数量的整数类型参数。我们可以使用展开运算符，将一个可迭代对象中的元素逐个传递给 myFunc 函数，分别作为不同的参数进行处理。在第一个示例中，我们以普通的方式传递了三个不同的整数参数。而在第二个示例中，我们用展开运算符将一个整数切片中的元素逐个传递给了 myFunc 函数。</p>
<p>此外，在 Go 语言中，展开运算符还可以用于数组&#x2F;切片的操作。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">b := []<span class="type">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">c := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line">d := <span class="built_in">append</span>(a, b...) <span class="comment">// 将 b 中的元素展开后添加到 a 中</span></span><br><span class="line">fmt.Println(d) <span class="comment">// 输出：[1 2 3 4 5 6]</span></span><br><span class="line"></span><br><span class="line">e := <span class="built_in">append</span>(a[:<span class="number">1</span>], c...) <span class="comment">// 将 c 中的元素展开后添加到 a[:1] 中</span></span><br><span class="line">fmt.Println(e) <span class="comment">// 输出：[1 7 8 9]</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们使用了展开运算符，在数组&#x2F;切片的操作中匀出了极大的力量。我们可以将一个切片中的元素展开放到另一个切片中，也可以通过将切片中的某个片段展开，将其插入到其他的切片中去。</p>
<p>综上所述，展开运算符在 Go 语言中有着非常广泛的应用场景，可以帮助我们简化代码，提高代码的可读性和灵活性。</p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>变量是一种使用方便的占位符，用于引用计算机内存地址。</p>
<p>Go 语言的取地址符是 &amp;，放到一个变量前使用就会返回相应变量的内存地址。</p>
<p>引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>
<p>例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义交换值函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x *<span class="type">int</span>, y *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line">   temp = *x    <span class="comment">/* 保持 x 地址上的值 */</span></span><br><span class="line">   *x = *y      <span class="comment">/* 将 y 值赋给 x */</span></span><br><span class="line">   *y = temp    <span class="comment">/* 将 temp 值赋给 y */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了特殊的数据结构(<code>slice</code>或者<code>map</code>)外，默认都是值传递。</p>
<h3 id="自定义数据类型名称"><a href="#自定义数据类型名称" class="headerlink" title="自定义数据类型名称"></a>自定义数据类型名称</h3><p><code>type</code>是一个关键字，用于声明类型的名称</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一些类型定义声明</span></span><br><span class="line"><span class="keyword">type</span> status <span class="type">bool</span>     <span class="comment">// status和bool是两个不同的类型</span></span><br><span class="line"><span class="keyword">type</span> MyString <span class="type">string</span> <span class="comment">// MyString和string是两个不同的类型</span></span><br><span class="line"><span class="keyword">type</span> Id <span class="type">uint64</span>       <span class="comment">// Id和uint64是两个不同的类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="built_in">real</span> <span class="type">float32</span>    <span class="comment">// real和float32是两个不同的类型// 一些类型别名声明</span></span><br><span class="line"><span class="keyword">type</span> boolean = <span class="type">bool</span> <span class="comment">// boolean和bool表示同一个类型</span></span><br><span class="line"><span class="keyword">type</span> Text = <span class="type">string</span>  <span class="comment">// Text和string表示同一个类型</span></span><br><span class="line"><span class="keyword">type</span> U8 = <span class="type">uint8</span>     <span class="comment">// U8、uint8和 byte表示同一个类型</span></span><br><span class="line"><span class="keyword">type</span> char = <span class="type">rune</span>    <span class="comment">// char、rune和int32表示同一个类型</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h2><h3 id="单变量的定义"><a href="#单变量的定义" class="headerlink" title="单变量的定义"></a>单变量的定义</h3><p>方式一：声明一个变量 默认的值是0</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>方法二：声明一个变量，初始化一个值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b <span class="type">int</span> = <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>方法三：在初始化的时候，可以省去数据类型，通过值自动匹配当前的变量的数据类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>方法四：(<strong>常用的方法</strong>:&#x3D;&#x3D;冒等&#x3D;&#x3D;) 省去var关键字，直接自动匹配</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e := <span class="number">100</span></span><br></pre></td></tr></table></figure>

<h3 id="多变量的定义"><a href="#多变量的定义" class="headerlink" title="多变量的定义"></a>多变量的定义</h3><p>方式五：初始化多个变量，写在一行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xx, yy <span class="type">int</span> = <span class="number">100</span>, <span class="number">200</span></span><br><span class="line"><span class="keyword">var</span> kk, ll = <span class="number">100</span>, <span class="string">&quot;Aceld&quot;</span></span><br></pre></td></tr></table></figure>

<p>方式六：初始化多个变量，写在一个小括号内</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    vv <span class="type">int</span>  = <span class="number">100</span></span><br><span class="line">    jj <span class="type">bool</span> = <span class="literal">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="局部变量与全局变量的说明"><a href="#局部变量与全局变量的说明" class="headerlink" title="局部变量与全局变量的说明"></a>局部变量与全局变量的说明</h3><p>除了冒等<code>:=</code>只能声明函数体内的局部变量外，其余的都是既可以声明局部变量，又能声明全局变量。</p>
<h2 id="常量的定义"><a href="#常量的定义" class="headerlink" title="常量的定义"></a>常量的定义</h2><h3 id="单常量与多常量定义"><a href="#单常量与多常量定义" class="headerlink" title="单常量与多常量定义"></a>单常量与多常量定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a <span class="type">string</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">const</span> d, e, c = <span class="number">1</span>, <span class="literal">false</span>, <span class="string">&quot;str&quot;</span> <span class="comment">//多重赋值</span></span><br></pre></td></tr></table></figure>

<p>注意，常量可以直接声明在包中，也可以声明在函数体中。 声明在函数体中的常量称为<strong>局部常量</strong>（local constant），直接声明在包中的常量称为<strong>包级常量</strong>（package-level constant）。 包级常量也常常被称为<strong>全局常量</strong>。</p>
<h3 id="枚举常量的定义"><a href="#枚举常量的定义" class="headerlink" title="枚举常量的定义"></a>枚举常量的定义</h3><p><strong>手工枚举量定义</strong>：适用于枚举量不多时</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Unknown = <span class="number">0</span></span><br><span class="line">    Female = <span class="number">1</span></span><br><span class="line">    Male = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    CCVisa            = <span class="string">&quot;Visa&quot;</span></span><br><span class="line">    CCMasterCard      = <span class="string">&quot;MasterCard&quot;</span></span><br><span class="line">    CCAmericanExpress = <span class="string">&quot;American Express&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>自动枚举量定义</strong>：适用于枚举量多且每个枚举量无值的意义的情景</p>
<p>使用<code>iota</code>标识符，可以<strong>自增长</strong></p>
<blockquote>
<ol>
<li><p>&#x3D;&#x3D;可以在const() 添加一个关键字 iota， 每行的iota都会累加1, 第一行的iota的默认值是0&#x3D;&#x3D;</p>
</li>
<li><p><code>iota</code>只能与const在一起用</p>
</li>
</ol>
</blockquote>
<p>例子1  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	a = <span class="literal">iota</span>	 <span class="comment">//iota = 0, a = 0</span></span><br><span class="line">	b 		  <span class="comment">//iota = 1, b = 1</span></span><br><span class="line">	c          <span class="comment">//iota = 2, c = 2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>例子2</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	a = <span class="literal">iota</span>*<span class="number">10</span>	 <span class="comment">//iota = 0, a = 0</span></span><br><span class="line">	b 		  <span class="comment">//iota = 1, b = 10</span></span><br><span class="line">	c          <span class="comment">//iota = 2, c = 20</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>例子3</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	a,d = <span class="literal">iota</span>+<span class="number">1</span>,<span class="literal">iota</span>+<span class="number">2</span> <span class="comment">//iota = 0, a = iota+1 = 1,d = iota+2 = 2</span></span><br><span class="line">	b,e 		  <span class="comment">//iota = 1, b = 2,e = 3</span></span><br><span class="line">	c,f          <span class="comment">//iota = 2, c = 3,f = 4</span></span><br><span class="line">    g = <span class="literal">iota</span>*<span class="number">3</span>  <span class="comment">//iota = 3,g = 9</span></span><br><span class="line">    h           <span class="comment">//iota = 4,h = 12</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><h3 id="简单介绍与注意事项"><a href="#简单介绍与注意事项" class="headerlink" title="简单介绍与注意事项"></a>简单介绍与注意事项</h3><p><strong>简单介绍</strong></p>
<p>每一个程序都包含很多的函数：函数是基本的代码块。</p>
<p>Go是编译型语言，所以函数编写的顺序是无关紧要的；鉴于可读性的需求，最好把 <code>main()</code> 函数写在文件的前面，其他函数按照一定逻辑顺序进行编写（例如函数被调用的顺序）。</p>
<p>当函数执行到代码块最后一行（<code>&#125;</code> 之前）或者 <code>return</code> 语句的时候会退出，其中 <code>return</code> 语句可以带有零个或多个参数；这些参数将作为返回值供调用者使用。简单的 <code>return</code> 语句也可以用来结束 for 死循环，或者结束一个协程（goroutine）。</p>
<p><strong>Go 里面有三种类型的函数</strong>：</p>
<ul>
<li>普通的带有名字的函数</li>
<li>匿名函数或者lambda函数</li>
<li>方法（Methods）</li>
</ul>
<p><strong>除了main()、init()函数外</strong>，其它所有类型的函数都可以有参数与返回值。<u>函数参数、返回值以及它们的类型</u>被统称为<strong>函数签名</strong>。</p>
<p>如果需要申明一个在外部定义的函数，你只需要给出函数名与函数签名，不需要给出函数体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flushICache</span><span class="params">(begin, end <span class="type">uintptr</span>)</span></span> <span class="comment">// implemented externally</span></span><br></pre></td></tr></table></figure>



<p><strong>注意事项</strong></p>
<ol>
<li>golang的函数不支持默认参数值</li>
</ol>
<blockquote>
<p>这个问题相当麻烦，根据<a target="_blank" rel="noopener" href="https://groups.google.com/g/golang-nuts/c/-5MCaivW0qQ?pli=1">golang-nuts&#x2F;google groups</a>中的这篇文章，golang现在与将来都不会支持参数默认值。Go始终在使得自己变得尽可能的简单，而增加这种额外的支持会使parser变得更复杂。</p>
</blockquote>
<ol start="2">
<li>函数不能声明在一个函数体内</li>
</ol>
<blockquote>
<p>注意，在Go中，所有函数都必须直接声明在包级代码块中。 或者说，任何一个函数都不能被声明在另一个函数体内。 虽然匿名函数（将在下面的某节中介绍）可以定义在函数体内，但匿名函数定义不属于函数声明。</p>
</blockquote>
<ol start="3">
<li>函数的访问权限</li>
</ol>
<blockquote>
<p>函数名大写表示该函数为Public可以被其它package调用，小写为private，不可以被其它包调用。</p>
</blockquote>
<ol start="4">
<li>函数的语法注意</li>
</ol>
<blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//错误的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="5">
<li>函数重载是不被允许的。这将导致一个编译错误</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">funcName redeclared in this book, previous declaration at lineno</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Go 语言不支持这项特性的主要原因是函数重载需要进行多余的类型匹配影响性能；没有重载意味着只是一个简单的函数调度。所以你需要给不同的函数使用不同的名字</p>
</blockquote>
<h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><p>函数定义时，它的形参一般是有名字的，不过我们也可以定义没有形参名的函数，只有相应的形参类型，就像这样：<code>func f(int, int, float64)</code>。</p>
<p>没有参数的函数通常被称为 <strong>niladic</strong> 函数（niladic function），就像 <code>main.main()</code>。</p>
<h4 id="按值传递-VS-按引用传递"><a href="#按值传递-VS-按引用传递" class="headerlink" title="按值传递 VS 按引用传递"></a><strong>按值传递 VS 按引用传递</strong></h4><p>Go <u>默认使用按值传递来传递参数</u>，也就是传递参数的副本。函数接收参数副本之后，在使用变量的过程中可能对副本的值进行更改，但不会影响到原来的变量，比如 <code>Function(arg1)</code>。</p>
<p>如果你希望函数可以直接修改参数的值，而不是对参数的副本进行操作，你需要将参数的地址（变量名前面添加&amp;符号，比如 &amp;variable）传递给函数，这就是按引用传递，比如 <code>Function(&amp;arg1)</code>，此时传递给函数的是一个指针。如果传递给函数的是一个指针，指针的值（一个地址）会被复制，但指针的值所指向的地址上的值不会被复制；我们可以通过这个指针的值来修改这个值所指向的地址上的值。（<strong>译者注：指针也是变量类型，有自己的地址和值，通常指针的值指向一个变量的地址。所以，按引用传递也是按值传递。</strong>）</p>
<p><em>几乎在任何情况下，传递指针（一个32位或者64位的值）的消耗都比传递副本来得少</em>。</p>
<p>在函数调用时，像切片（slice）、字典（map）、接口（interface）、通道（channel）这样的引用类型都是默认使用引用传递（即使没有显式的指出指针）。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://books.studygolang.com/the-way-to-go_ZH_CN/06.2.html">函数参数与返回值 · Go入门指南 (studygolang.com)</a></p>
<h4 id="传递变长参数"><a href="#传递变长参数" class="headerlink" title="传递变长参数"></a>传递变长参数</h4><p>如果函数的最后一个参数是采用 <code>...type</code> 的形式，那么这个函数就可以处理一个变长的参数，这个长度可以为 0，这样的函数称为变参函数。变长函数声明和普通函数声明类似，只不过最后一个参数必须为变长参数。 <strong>一个变长参数在函数体内将被视为一个切片。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">(a, b, arg ...<span class="type">int</span>)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个函数的最后一个参数可以是一个变长参数；</li>
<li>一个函数可以最多有一个变长参数；</li>
<li>一个变长参数的类型总为一个切片类型。</li>
</ul>
<p>例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sum返回所有输入实参的和。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(values ...<span class="type">int64</span>)</span></span> (sum <span class="type">int64</span>) &#123;</span><br><span class="line">	<span class="comment">// values的类型为[]int64。</span></span><br><span class="line">	sum = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">		sum += v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concat是一个低效的字符串拼接函数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Concat</span><span class="params">(sep <span class="type">string</span>, tokens ...<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="comment">// tokens的类型为[]string。</span></span><br><span class="line">	r := <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i, t := <span class="keyword">range</span> tokens &#123;</span><br><span class="line">		<span class="keyword">if</span> i != <span class="number">0</span> &#123;</span><br><span class="line">			r += sep</span><br><span class="line">		&#125;</span><br><span class="line">		r += t</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的两个变长参数函数声明可以看出，如果一个变长参数的类型部分为<code>...T</code>，则此变长参数的类型实际为<code>[]T</code>。</p>
<p><strong>变长参数类型不同的解决方案</strong></p>
<p>但是如果变长参数的类型并不是都相同的呢？使用 5 个参数来进行传递并不是很明智的选择，有 2 种方案可以解决这个问题：</p>
<ol>
<li><p>使用结构（详见第 10 章）：</p>
<p>定义一个结构类型，假设它叫 <code>Options</code>，用以存储所有可能的参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Options <span class="keyword">struct</span> &#123;</span><br><span class="line">    par1 type1,</span><br><span class="line">    par2 type2,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数 F1 可以使用正常的参数 a 和 b，以及一个没有任何初始化的 Options 结构： <code>F1(a, b, Options &#123;&#125;)</code>。如果需要对选项进行初始化，则可以使用 <code>F1(a, b, Options &#123;par1:val1, par2:val2&#125;)</code>。</p>
</li>
<li><p>使用空接口：</p>
<p>如果一个变长参数的类型没有被指定，则可以使用默认的空接口 <code>interface&#123;&#125;</code>，这样就可以接受任何类型的参数（详见第 11.9 节）。该方案不仅可以用于长度未知的参数，还可以用于任何不确定类型的参数。一般而言我们会使用一个 for-range 循环以及 switch 结构对每个参数的类型进行判断：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typecheck</span><span class="params">(..,..,values … <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> values &#123;</span><br><span class="line">        <span class="keyword">switch</span> v := value.(<span class="keyword">type</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">int</span>: …</span><br><span class="line">            <span class="keyword">case</span> float: …</span><br><span class="line">            <span class="keyword">case</span> <span class="type">string</span>: …</span><br><span class="line">            <span class="keyword">case</span> <span class="type">bool</span>: …</span><br><span class="line">            <span class="keyword">default</span>: …</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>我们通过 <code>return</code> 关键字返回一组值。事实上，任何一个有返回值（单个或多个）的函数都必须以 <code>return</code> 或 <code>panic</code>（参考 <a target="_blank" rel="noopener" href="https://books.studygolang.com/the-way-to-go_ZH_CN/13.0.html">第 13 章</a>）结尾。</p>
<p>在函数块里面，<code>return</code> 之后的语句都不会执行。如果一个函数需要返回值，那么这个函数里面的<strong>每一个代码分支（code-path）都要有 <code>return</code> 语句</strong>。</p>
<blockquote>
<p>如果有一个代码分支里没有，那么就会编译失败</p>
</blockquote>
<ol>
<li>单返回值</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单返回值，匿名返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">testfunc</span><span class="params">(a <span class="type">string</span>,b <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">res1 = testfunc(<span class="string">&quot;test&quot;</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>多返回值，匿名返回</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多返回值，匿名返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">testfunc</span><span class="params">(a <span class="type">string</span>,b <span class="type">int</span>)</span></span> <span class="type">int</span>,<span class="type">string</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>,<span class="string">&quot;2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">res1,res2 = testfunc(<span class="string">&quot;test&quot;</span>,<span class="number">1</span>)</span><br><span class="line">res1,_ = testfunc(<span class="string">&quot;test&quot;</span>,<span class="number">1</span>)<span class="comment">//匿名接受</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>多返回值，有名形参返回</li>
</ol>
<p><strong>尽量使用命名返回值：会使代码更清晰、更简短，同时更加容易读懂。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多返回值，有名返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">testfunc</span><span class="params">(a <span class="type">string</span>,b <span class="type">int</span>)</span></span> (r1 <span class="type">int</span>,r2 <span class="type">string</span>)&#123;</span><br><span class="line">    r1 = <span class="number">1</span></span><br><span class="line">    r2 = <span class="string">&quot;2&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">//直接返回r1,r2</span></span><br><span class="line">&#125;</span><br><span class="line">res1,res2 = testfunc(<span class="string">&quot;test&quot;</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<h3 id="函数作为数据类型"><a href="#函数作为数据类型" class="headerlink" title="函数作为数据类型"></a>函数作为数据类型</h3><ol>
<li>函数作为一种数据类型，进行声明变量</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">testfunc</span><span class="params">(a <span class="type">string</span>,b <span class="type">int</span>)</span></span> (r1 <span class="type">int</span>,r2 <span class="type">string</span>)&#123;</span><br><span class="line">    r1 = <span class="number">1</span></span><br><span class="line">    r2 = <span class="string">&quot;2&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">//直接返回r1,r2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line">f1:=testfunc</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="keyword">var</span> f2 <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>,<span class="type">int</span>)</span></span> (<span class="type">int</span>,<span class="type">int</span>)=testfunc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>函数作为一种数据类型，作为函数的形参</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数作为参数传</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testfunc</span><span class="params">(f1 <span class="keyword">func</span>(<span class="type">int</span>,<span class="type">int</span>)</span></span> <span class="type">int</span>,a1 <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> f1(a1,a1)+a1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以采用别名的方式简化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取个别名传</span></span><br><span class="line"><span class="keyword">type</span> myFunc <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testfunc</span><span class="params">(f3 myFunc,a4 <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> f3(a4,a4)+a4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="匿名函数-又称为闭包"><a href="#匿名函数-又称为闭包" class="headerlink" title="匿名函数(又称为闭包)"></a>匿名函数(又称为闭包)</h3><p>Go支持匿名函数。定义一个匿名函数和声明一个函数类似，但是一个匿名函数的定义中不包含函数名称部分。 注意匿名函数定义不是一个函数声明。</p>
<p><strong>一个匿名函数在定义后可以被立即调用</strong>，只用在定义完后<strong>加个小括号</strong>即可直接调用。比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这个匿名函数没有输入参数，但有两个返回结果。</span></span><br><span class="line">    x, y := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;This fucntion has no parameters.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">    &#125;() <span class="comment">// 一对小括号表示立即调用此函数。不需传递实参。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面这些匿名函数没有返回结果。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;a*a + b*b =&quot;</span>, a*a + b*b) <span class="comment">// a*a + b*b = 25</span></span><br><span class="line">    &#125;(x, y) <span class="comment">// 立即调用并传递两个实参。</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 形参x遮挡了外层声明的变量x。</span></span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;x*x + y*y =&quot;</span>, x*x + y*y) <span class="comment">// x*x + y*y = 32</span></span><br><span class="line">    &#125;(y) <span class="comment">// 将实参y传递给形参x。</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;x*x + y*y =&quot;</span>, x*x + y*y) <span class="comment">// x*x + y*y = 25</span></span><br><span class="line">    &#125;() <span class="comment">// 不需传递实参。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一个匿名函数可以被赋值给某个函数类型的值</strong>，从而我们不必在定义完此匿名函数后立即调用它，而是可以在以后合适的时候再调用它。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">compareNum := <span class="function"><span class="keyword">func</span> <span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (n - a) </span><br><span class="line">&#125;<span class="comment">//匿名函数的赋值</span></span><br><span class="line"></span><br><span class="line">res := compareNum(guessNum)<span class="comment">//匿名函数的使用</span></span><br></pre></td></tr></table></figure>

<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p>Go 语言拥有一些不需要进行导入操作就可以使用的内置函数。它们有时可以针对不同的类型进行操作，例如：len、cap 和 append，或必须用于系统级的操作，例如：panic。因此，它们需要直接获得编译器的支持。</p>
<p>以下是一个简单的列表：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">close</td>
<td align="left">用于管道通信</td>
</tr>
<tr>
<td align="left">len、cap</td>
<td align="left">len 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；cap 是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map）</td>
</tr>
<tr>
<td align="left">new、make</td>
<td align="left">new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针（详见第 10.1 节）。它也可以被用于基本类型：<code>v := new(int)</code>。make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作（详见第 7.2.3&#x2F;4 节、第 8.1.1 节和第 14.2.1 节）<strong>new() 是一个函数，不要忘记它的括号</strong></td>
</tr>
<tr>
<td align="left">copy、append</td>
<td align="left">用于复制和连接切片</td>
</tr>
<tr>
<td align="left">panic、recover</td>
<td align="left">两者均用于错误处理机制</td>
</tr>
<tr>
<td align="left">print、println</td>
<td align="left">底层打印函数（详见第 4.2 节），在部署环境中建议使用 fmt 包</td>
</tr>
<tr>
<td align="left">complex、real imag</td>
<td align="left">用于创建和操作复数（详见第 4.5.2.2 节）</td>
</tr>
</tbody></table>
<h3 id="函数的退出阶段：defer关键字"><a href="#函数的退出阶段：defer关键字" class="headerlink" title="函数的退出阶段：defer关键字"></a>函数的退出阶段：defer关键字</h3><p><strong>defer关键字的作用</strong></p>
<blockquote>
<p>关键字 defer 允许我们推迟到函数返回之前（或任意位置执行 <code>return</code> 语句之后）一刻才执行某个语句或函数（为什么要在返回之后才执行这些语句？因为 <code>return</code> 语句同样可以包含一些操作，而不是单纯地返回某个值）。</p>
<p>关键字 defer 的用法类似于面向对象编程语言 Java 和 C# 的 <code>finally</code> 语句块，它一般用于释放某些已分配的资源。</p>
</blockquote>
<p><strong>多个defer语句的执行顺序</strong></p>
<p>在函数return之后，才会执行defer关键字后的语句。如果有多个defer语句，会以代码在文档中的顺序把defer语句入栈，return后含出栈顺序执行。</p>
<p><img src="https://gitee.com/yushen611/img/raw/master/image-20230317150608883.png" alt="image-20230317150608883"></p>
<p>使用场景</p>
<p>关键字 defer 允许我们进行一些函数执行完成后的收尾工作，例如：</p>
<ol>
<li>关闭文件流</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// open a file  </span></span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>解锁一个加锁的资源</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mu.Lock()  </span><br><span class="line"><span class="keyword">defer</span> mu.Unlock()</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>打印最终报告</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printHeader()  </span><br><span class="line"><span class="keyword">defer</span> printFooter()</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>关闭数据库链接</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// open a database connection  </span></span><br><span class="line"><span class="keyword">defer</span> disconnectFromDB()</span><br></pre></td></tr></table></figure>



<h2 id="基本流程控制语法"><a href="#基本流程控制语法" class="headerlink" title="基本流程控制语法"></a>基本流程控制语法</h2><p>Go语言中有<strong>三种基本的流程控制代码块</strong>：</p>
<ul>
<li><code>if-else</code>条件分支代码块；</li>
<li><code>for</code>循环代码块；</li>
<li><code>switch-case</code>多条件分支代码块。</li>
</ul>
<p>Go中另外<strong>还有几种和特定种类的类型相关的流程控制代码块</strong>：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/Golang101-v1.16.a-1/container.html#iteration">容器类型</a>相关的<code>for-range</code>循环代码块。</li>
<li><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/Golang101-v1.16.a-1/interface.html#type-switch">接口类型</a>相关的<code>type-switch</code>多条件分支代码块。</li>
<li><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/Golang101-v1.16.a-1/channel.html#select">通道类型</a>相关的<code>select-case</code>多分支代码块。</li>
</ul>
<p>和很多其它流行语言一样，Go也支持<code>break</code>、<code>continue</code>和<code>goto</code>等跳转语句。 另外，Go还支持一个特有的<code>fallthrough</code>跳转语句。</p>
<p>Go所支持的六种流程控制代码块中，除了<code>if-else</code>条件分支代码块，其它五种称为可跳出代码块。 我们可以在一个可跳出代码块中使用<code>break</code>语句以跳出此代码块。</p>
<p>我们可以在<code>for</code>和<code>for-range</code>两种循环代码块中使用<code>continue</code>语句提前结束一个循环步。 除了这两种循环代码块，其它四种代码块称为分支代码块。</p>
<p>请注意，上面所提及的每种流程控制的一个分支都属于一条语句。这样的语句常常会包含很多子语句。</p>
<p>上面所提及的流程控制语句都属于狭义上的流程控制语句。 下一篇文章中将要介绍的<a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/Golang101-v1.16.a-1/control-flows-more.html">协程、延迟函数调用、以及恐慌和恢复</a>，以及今后要介绍的<a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/Golang101-v1.16.a-1/concurrent-synchronization-overview.html">并发同步技术</a>属于广义上的流程控制语句。</p>
<p>本文余下的部分将只解释三种基本的流程控制语句和各种代码跳转语句。其它上面提及的语句将在后面其它文章中逐渐介绍。</p>
<h3 id="if-else条件分支控制代码块"><a href="#if-else条件分支控制代码块" class="headerlink" title="if-else条件分支控制代码块"></a><code>if-else</code>条件分支控制代码块</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> InitSimpleStatement; Condition &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一个<code>if-else</code>条件分支控制代码块中，</p>
<ul>
<li><code>InitSimpleStatement</code>部分是可选的，如果它没被省略掉，则它必须为一条<a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/Golang101-v1.16.a-1/expressions-and-statements.html#simple-statements">简单语句</a>。 如果它被省略掉，它可以被视为一条空语句（简单语句的一种）。 在实际编程中，<code>InitSimpleStatement</code>常常为一条变量短声明语句。</li>
<li><code>Condition</code>必须为一个结果为布尔值的<a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/Golang101-v1.16.a-1/expressions-and-statements.html#expressions">表达式</a>（它被称为条件表达式）。 <code>Condition</code>部分可以用一对小括号括起来，但大多数情况下不需要。</li>
</ul>
<p>注意，我们<strong>不能用一对小括号</strong>将<code>InitSimpleStatement</code>和<code>Condition</code>两部分括在一起。</p>
<p>在执行一个<code>if-else</code>条件分支控制代码块中，如果<code>InitSimpleStatement</code>这条语句没有被省略，则此条语句将被率先执行。 如果<code>InitSimpleStatement</code>被省略掉，则其后跟随的分号<code>;</code>也可一块儿被省略。</p>
<p>例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用InitSimpleStatement</span></span><br><span class="line"><span class="keyword">if</span> n := rand.Int(); n%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Println(n, <span class="string">&quot;是一个偶数。&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(n, <span class="string">&quot;是一个奇数。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不使用InitSimpleStatement</span></span><br><span class="line">n := rand.Int() % <span class="number">2</span> <span class="comment">// 此n不是上面声明的n</span></span><br><span class="line"><span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;一个偶数。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ; n % <span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;一个奇数。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for循环代码块"><a href="#for循环代码块" class="headerlink" title="for循环代码块"></a><code>for</code>循环代码块</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> InitSimpleStatement; Condition; PostSimpleStatement &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一个<code>for</code>循环代码块中，</p>
<ul>
<li><code>InitSimpleStatement</code>（初始化语句）和<code>PostSimpleStatement</code>（步尾语句）两个部分必须均为简单语句，并且<code>PostSimpleStatement</code>不能为一个变量短声明语句。</li>
<li><code>Condition</code>必须为一个结果为布尔值的表达式（它被称为条件表达式）。</li>
</ul>
<p><strong>这三个部分都是可选的</strong>。和很多其它流行语言不同，在Go中上述三部分<strong>不能用小括号括在一起</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>只有条件表达式的for循环：用于代替while循环</strong></p>
<p>在一个<code>for</code>循环流程控制中，如果<code>InitSimpleStatement</code>和<code>PostSimpleStatement</code>两部分同时被省略（可将它们视为空语句），则和它们相邻的两个<strong>分号也可被省略</strong>。 这样的形式被称为只有条件表达式的<code>for</code>循环。只有条件表达式的<code>for</code>循环和很多其它语言中的<code>while</code>循环类似。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"><span class="comment">//可以省略分号，也可以不省略</span></span><br><span class="line"><span class="keyword">for</span> ; i &lt; <span class="number">10</span>; &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样就等于while循环了</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="number">20</span> &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="switch-case流程控制代码块"><a href="#switch-case流程控制代码块" class="headerlink" title="switch-case流程控制代码块"></a><code>switch-case</code>流程控制代码块</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> InitSimpleStatement; CompareOperand0 &#123;</span><br><span class="line"><span class="keyword">case</span> CompareOperandList1:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line"><span class="keyword">case</span> CompareOperandList2:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> CompareOperandListN:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一个<code>switch-case</code>流程控制代码块中，</p>
<ul>
<li><code>InitSimpleStatement</code>部分必须为一条简单语句，它是可选的。</li>
<li><code>CompareOperand0</code>部分必须为一个表达式（如果它没被省略的话，见下）。 此表达式的估值结果总是被视为一个类型确定值。如果它是一个类型不确定值，则它被视为类型为它的默认类型的类型确定值。 因为这个原因，此表达式不能为类型不确定的<code>nil</code>值。 <code>CompareOperand0</code>常被称为switch表达式。</li>
<li>每个<code>CompareOperandListX</code>部分（<code>X</code>表示<code>1</code>到<code>N</code>）必须为一个用（英文）逗号分隔开来的表达式列表。 其中每个表达式都必须能和<code>CompareOperand0</code>表达式进行比较。 每个这样的表达式常被称为case表达式。 如果其中case表达式是一个类型不确定值，则它必须能够自动隐式转化为对应的switch表达式的类型，否则编译将失败。</li>
</ul>
<p>注意：</p>
<ol>
<li><p>每个<code>switch-case</code>流程控制代码块中最多只能有一个<code>default</code>分支（默认分支）。</p>
</li>
<li><p><code>switch-case</code>代码块属于可跳出流程控制。 <code>break</code>可以使用在一个<code>switch-case</code>流程控制的任何分支代码块之中以提前跳出此<code>switch-case</code>流程控制。</p>
</li>
<li><p>当一个<code>switch-case</code>流程控制被执行到的时候，其中的简单语句<code>InitSimpleStatement</code>将率先被执行。 随后switch表达式<code>CompareOperand0</code>将被估值（仅一次）。上面已经提到，此估值结果一定为一个类型确定值。 然后此结果值将从上到下从左到右和各个<code>CompareOperandListX</code>表达式列表中的各个case表达式逐个依次比较（使用<code>==</code>运算符）。 一旦发现某个表达式和<code>CompareOperand0</code>相等，比较过程停止并且此表达式对应的分支代码块将得到执行。 如果没有任何一个表达式和<code>CompareOperand0</code>相等，则<code>default</code>默认分支将得到执行（如果此分支存在的话）。</p>
</li>
<li><p>Go中另外一个和其它语言的显著不同点是<code>default</code>分支不必一定为最后一个分支</p>
</li>
</ol>
<p>一个<code>switch-case</code>流程控制的例子：</p>
<p><strong>和很多其它语言不一样，程序不会自动从一个分支代码块跳到下一个分支代码块去执行</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"><span class="keyword">switch</span> n := rand.Intn(<span class="number">100</span>); n%<span class="number">9</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    fmt.Println(n, <span class="string">&quot;is a multiple of 9.&quot;</span>)</span><br><span class="line">    <span class="comment">// 和很多其它语言不一样，程序不会自动从一个</span></span><br><span class="line">    <span class="comment">// 分支代码块跳到下一个分支代码块去执行。</span></span><br><span class="line">    <span class="comment">// 所以，这里不需要一个break语句。</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>:</span><br><span class="line">    fmt.Println(n, <span class="string">&quot;mod 9 is 1, 2 or 3.&quot;</span>)</span><br><span class="line">    <span class="keyword">break</span> <span class="comment">// 这里的break语句可有可无的，效果</span></span><br><span class="line">    <span class="comment">// 是一样的。执行不会跳到下一个分支。</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>:</span><br><span class="line">    fmt.Println(n, <span class="string">&quot;mod 9 is 4, 5 or 6.&quot;</span>)</span><br><span class="line">    <span class="comment">// case 6, 7, 8:</span></span><br><span class="line">    <span class="comment">// 上一行可能编译不过，因为6和上一个case中的</span></span><br><span class="line">    <span class="comment">// 6重复了。是否能编译通过取决于具体编译器实现。</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(n, <span class="string">&quot;mod 9 is 7 or 8.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何让执行从一个<code>case</code>分支代码块的结尾跳入下一个分支代码块？Go提供了一个<code>fallthrough</code>关键字来完成这个任务。</p>
<p>在下面的例子中，所有的分支代码块都将得到执行（从上到下）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"><span class="keyword">switch</span> n := rand.Intn(<span class="number">100</span>) % <span class="number">5</span>; n &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;n =&quot;</span>, n)</span><br><span class="line">    <span class="keyword">fallthrough</span> <span class="comment">// 跳到下个代码块</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>:</span><br><span class="line">    <span class="comment">// 一个新声明的n，它只在当前分支代码快内可见。</span></span><br><span class="line">    n := <span class="number">99</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;n =&quot;</span>, n) <span class="comment">// 99</span></span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 下一行中的n和第一个分支中的n是同一个变量。</span></span><br><span class="line">    <span class="comment">// 它们均为switch表达式&quot;n&quot;。</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;n =&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>一条<code>fallthrough</code>语句必须为一个分支代码块中的最后一条语句。</li>
<li>一条<code>fallthrough</code>语句不能出现在一个<code>switch-case</code>流程控制中的最后一个分支代码块中。</li>
</ul>
<h1 id="三、数据结构与算法"><a href="#三、数据结构与算法" class="headerlink" title="三、数据结构与算法"></a>三、数据结构与算法</h1><h2 id="包引入与包管理"><a href="#包引入与包管理" class="headerlink" title="包引入与包管理"></a>包引入与包管理</h2><h3 id="包引入"><a href="#包引入" class="headerlink" title="包引入"></a>包引入</h3><h4 id="包引入的方式"><a href="#包引入的方式" class="headerlink" title="包引入的方式"></a>包引入的方式</h4><p>不同的引入语法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单条引入</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math/rand&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一条包引入语句引入了三个代码包。</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>事实上，一个引入声明语句的完整形式为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> importAliasName <span class="string">&quot;path/.../package&quot;</span></span><br></pre></td></tr></table></figure>

<p>注：如果不是内置的包，而是<strong>项目自定义的包</strong>(<em>自定义的包又叫做模块，模块（module）为的若干代码包的集合</em>)，path为当前项目的根目录</p>
<blockquote>
<p>注意，如果项目使用了<strong>go mod进行依赖管理</strong>，那么此时path还是根目录，但是<strong>根目录名称为</strong>go mod init anyName.com中的<strong>anyName.com</strong>。导包时如</p>
</blockquote>
<p><strong>取别名</strong>的例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> rand <span class="string">&quot;math/rand&quot;</span> <span class="comment">// &lt;=&gt; import &quot;math/rand&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>如果想调用包的函数而不写包名</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    . <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    . <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果只想执行某个包的init函数而不调用该包的其他变量或方法，可以<strong>匿名引入</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">&quot;math/rand&quot;</span> <span class="comment">// okay: 匿名引入</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>





<h4 id="包引入时的执行顺序：包的init函数"><a href="#包引入时的执行顺序：包的init函数" class="headerlink" title="包引入时的执行顺序：包的init函数"></a>包引入时的执行顺序：包的init函数</h4><p>由于包引入时，会涉及到引入过程在干什么，因此需要重点了解一下包的init函数。</p>
<p><strong>初始化顺序</strong></p>
<p>golang程序初始化先于main函数执行，由runtime进行初始化，初始化顺序如下：</p>
<ol>
<li>初始化导入的包(导入的每个包也按如下顺序执行。参考下图)</li>
<li>初始化包作用域的变量</li>
<li>执行包的init函数；</li>
</ol>
<p><img src="https://gitee.com/yushen611/img/raw/master/image-20230317155426309.png" alt="image-20230317155426309"></p>
<p><strong>init函数的主要作用：</strong></p>
<ul>
<li><p>初始化不能采用初始化表达式初始化的变量。</p>
</li>
<li><p>程序运行前的注册。</p>
</li>
<li><p>实现sync.Once功能。</p>
</li>
</ul>
<p><strong>init函数的主要特点：</strong></p>
<ul>
<li>init函数先于main函数自动执行，不能被其他函数调用；</li>
<li><strong>init函数没有输入参数、返回值</strong>；</li>
<li>每个包可以有多个init函数；</li>
<li><strong>包的每个源文件也可以有多个init函数</strong>，这点比较特殊；</li>
<li>同一个包的init执行顺序，golang没有明确定义，编程时要注意程序不要依赖这个执行顺序。(同一个包不同源文件的init函数执行顺序，golang spec没做说明，根据实验来看，执行顺序是源文件名称的字典序。</li>
<li>不同包的init函数按照包导入的依赖关系决定执行顺序。</li>
</ul>
<p>一个文件多个init函数的例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;init 1&quot;</span>)<span class="comment">//输出顺序1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;init 2&quot;</span>)<span class="comment">//输出顺序2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;main&quot;</span>)<span class="comment">//输出顺序3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><h4 id="老的包管理：GOPATH"><a href="#老的包管理：GOPATH" class="headerlink" title="老的包管理：GOPATH"></a>老的包管理：GOPATH</h4><p>几乎所有的包管理工具在Go 1.11版本之前都绕不开GOPATH这个环境变量。GOPATH主要用来放置项目依赖包的源代码，GOPATH不区分项目，代码中任何import的路径均从GOPATH为根目录开始；</p>
<p><strong>GOPATH目录</strong>下一共包含了三个子目录，分别是：</p>
<ul>
<li>bin：存储所编译生成的二进制文件。</li>
<li>pkg：存储预编译的目标文件，以加快程序的后续编译速度。</li>
<li>src：存储所有<code>.go</code>文件或源代码。在编写 Go 应用程序，程序包和库时，一般会以<code>$GOPATH/src/github.com/foo/bar</code>的路径进行存放。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">go</span><br><span class="line">├── bin</span><br><span class="line">├── pkg</span><br><span class="line">└── src</span><br><span class="line">    ├── github.com</span><br><span class="line">    ├── golang.org</span><br><span class="line">    ├── google.golang.org</span><br><span class="line">    ├── gopkg.in</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>

<p>因此在使用 GOPATH 模式下，我们需要将应用代码存放在固定的<code>$GOPATH/src</code>目录下，并且如果执行<code>go get</code>来拉取外部依赖会自动下载并安装到<code>$GOPATH/src/</code>目录下。</p>
<p>但现在GOPATH已经不够用了。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>不区分依赖项版本</li>
<li>依赖项列表无法数据化</li>
</ul>
<h4 id="新的包管理：Go-Modules"><a href="#新的包管理：Go-Modules" class="headerlink" title="新的包管理：Go Modules"></a>新的包管理：Go Modules</h4><p>我们接下来用Go Modules的方式创建一个项目, 建议为了与GOPATH分开,不要将项目创建在<code>GOPATH/src</code>下</p>
<h5 id="go-mod命令"><a href="#go-mod命令" class="headerlink" title="go mod命令"></a>go mod命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>go mod init</strong></td>
<td>生成 go.mod 文件</td>
</tr>
<tr>
<td>go mod download</td>
<td>下载 go.mod 文件中指明的所有依赖</td>
</tr>
<tr>
<td><strong>go mod tidy</strong></td>
<td>整理现有的依赖</td>
</tr>
<tr>
<td>go mod graph</td>
<td>查看现有的依赖结构</td>
</tr>
<tr>
<td>go mod edit</td>
<td>编辑 go.mod 文件</td>
</tr>
<tr>
<td>go mod vendor</td>
<td>导出项目所有的依赖到vendor目录</td>
</tr>
<tr>
<td>go mod verify</td>
<td>校验一个模块是否被篡改过</td>
</tr>
<tr>
<td>go mod why</td>
<td>查看为什么需要依赖某模块</td>
</tr>
</tbody></table>
<p><strong>使用go mod管理项目的流程</strong></p>
<p><strong>(1)设置环境变量GO111MODULE为开</strong>(如果已经设置，可忽略)</p>
<p><code> $ go env -w GO111MODULE=on</code></p>
<p><strong>(2)进入项目根目录，生成go.mod文件</strong></p>
<p><code>go mod init &lt;域名:如ywy.com&gt;/&lt;项目名:如test_module&gt;</code></p>
<p>注：包名的规范一般就是<code>自己的域名</code>与<code>项目/功能名</code>的组合</p>
<p>此时就会生成一个go.mod文件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module ywy.com/test_module</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.20</span></span><br></pre></td></tr></table></figure>

<p><strong>(3)导入自定义项目包</strong></p>
<p>假设项目结构如下</p>
<p><img src="https://gitee.com/yushen611/img/raw/master/image-20230318143813507.png" alt="image-20230318143813507"></p>
<p>我想调用自己写的 ToolKit.go。ToolKit.go大致内容如今</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for all kind of tools</span></span><br><span class="line"><span class="keyword">package</span> Toolkit</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Left</span><span class="params">(str <span class="type">string</span>, cnt <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	l := strings.Count(str, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> cnt &gt;= l &#123;</span><br><span class="line">		cnt = l - <span class="number">1</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> l &lt; <span class="number">0</span> &#123;</span><br><span class="line">		l = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> str[<span class="number">0</span>:cnt]</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果我想在main.go中调用Toolkit包，只有一种写法是正确的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;ywy.com/test_module/ToolKit&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>(4)导入外部第三方包</strong></p>
<p>在<a target="_blank" rel="noopener" href="https://pkg.go.dev/">Go Packages</a>网站可以查看所有的第三方包</p>
<p>使用 <code>go get</code>下载包,如下载modbus包</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/goburrow/modbus</span><br></pre></td></tr></table></figure>

<p>在项目中执行go get命令可以下载依赖包，并且还可以指定下载的版本。</p>
<ul>
<li>运行go get -u将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号， y是次要版本号)</li>
<li>运行go get -u&#x3D;patch将会升级到最新的修订版本</li>
<li>运行go get package<a target="_blank" rel="noopener" href="https://github.com/version" title="@version">@version</a>将会升级到指定的版本号version<br>如果下载所有依赖可以使用go mod download命令。</li>
</ul>
<blockquote>
<p>使用go get获取的包.如果GO111MODULE 如果为off，则放在 $GOPATH&#x2F;src&#x2F;$ 目录下。如果GO111MODULE 如果为on，则放在 $GOPATH&#x2F;pkg&#x2F;$ 目录下。</p>
<p>使用go mod下载的依赖包放在 $GOPATH&#x2F;pkg&#x2F;mod&#x2F; 目录下，所有项目共享</p>
</blockquote>
<p><strong>(5)修改版本，更新依赖</strong></p>
<p>修改包的版本号直接去go.mod文件修改,然后<code>go mod download</code></p>
<p>此时会将依赖全部下载至 GOPATH 下的pkg&#x2F;mod文件夹中</p>
<p><strong>(6)如果想把项目依赖转移到本地项目文件夹</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> mod vendor</span><br></pre></td></tr></table></figure>

<p>执行此命令,会将刚才下载至 GOPATH 下的依赖转移至该项目根目录下的 vendor(自动新建) 文件夹下，此时我们就可以使用这些依赖了。然而实际不导入也是完全ok的。导入了反而更麻烦。</p>
<p>在协作中使用 GOMODULE时要注意的是, 在项目管理中,如使用git,请将 vendor 文件夹放入白名单,不然项目中带上包体积会很大。</p>
<p>git设置白名单方式为在git托管的项目根目录新建 .gitignore 文件</p>
<p>设置忽略即可。但是 go.mod 和 go.sum 不要忽略，另一人clone项目后在本地进行依赖更新(同上方依赖更新)即可。</p>
<p><strong>补充1：使用go mod命令下载一个外部依赖步骤</strong></p>
<ol>
<li>在你的Go项目中初始化一个新的模块：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init [module name]</span><br></pre></td></tr></table></figure>

<ol>
<li>执行以下命令来下载依赖项并更新go.mod文件：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get [module path]</span><br></pre></td></tr></table></figure>

<p>其中，[module path]是你想要下载的依赖项的路径。</p>
<p>例如，如果你想下载github.com&#x2F;gorilla&#x2F;mux这个包，可以执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/gorilla/mux</span><br></pre></td></tr></table></figure>

<p><strong>执行完这个命令后，go.mod文件会被更新，同时下载的依赖项会被放置在你的GOPATH或者go module缓存中</strong>。你可以通过运行以下命令来查看所有已经下载的依赖项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go list -m all</span><br></pre></td></tr></table></figure>

<p>这将会列出你当前项目所依赖的所有模块。</p>
<p>需要注意的是，如果你使用的是Go 1.16或更高版本，go get命令将自动使用go mod来管理依赖项。否则，你需要在执行go get命令前设置环境变量GO111MODULE为on来启用go mod模式。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _,ch := <span class="keyword">range</span>(s)&#123;</span><br><span class="line">    num := ch - <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    hashmap[num]++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p><strong>容器</strong>, 它是可以包含大量条目（item）的数据结构, 例如数组、切片和 map。从这看到 Go 明显受到 Python 的影响。有时候，我们可以认为字符串类型和通道类型也属于容器类型。 但是，此篇文章只谈及数组、切片和映射类型。</p>
<p>go中，所谓数组，就是静态数组。所谓切片，就是动态数组。</p>
<p><strong>由于不同容量的数组在go中被认为是不同的数据类型</strong>，因此基本<strong>不使用静态数组，而是直接使用切片</strong>。</p>
<h3 id="定义与初始化-make"><a href="#定义与初始化-make" class="headerlink" title="定义与初始化:make()"></a>定义与初始化:make()</h3><p><strong>声明切片的格式</strong>是： </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier []<span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>切片不需要说明长度。</p>
<p>区分切片和数组的创建</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建有 3 个元素的整型数组</span></span><br><span class="line">myArray := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建长度和容量都是 3 的整型切片</span></span><br><span class="line">mySlice := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure>



<p><strong>切片初始化</strong></p>
<p>一个切片在未初始化之前默认为 nil，长度为 0。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 直接初始化切片，[]表示是切片类型，&#123;1,2,3&#125;初始化值依次是1,2,3.其cap=len=3</span></span><br><span class="line">s :=[] <span class="type">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;</span><br><span class="line">q := []*TreeNode&#123;root&#125; <span class="comment">//初始化了一个包含单个节点 root 的指向 TreeNode 指针类型的切片</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 初始化切片s,是数组arr的引用</span></span><br><span class="line">s := arr[:]</span><br><span class="line">s := arr[startIndex:endIndex] <span class="comment">//将arr中从下标startIndex到endIndex-1 下的元素创建为一个新的切片</span></span><br><span class="line">s := arr[startIndex:] <span class="comment">//缺省endIndex时将表示一直到arr的最后一个元素</span></span><br><span class="line">s := arr[:endIndex] <span class="comment">//缺省startIndex时将表示从arr的第一个元素开始</span></span><br><span class="line">s1 := s[startIndex:endIndex]<span class="comment">//通过切片s初始化切片s1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 通过内置函数make()初始化切片s,也可以指定容量，len 是数组的长度并且也是切片的初始长度。其中capacity为可选参数。</span></span><br><span class="line">s :=<span class="built_in">make</span>([]<span class="type">int</span>,<span class="built_in">len</span>,<span class="built_in">cap</span>)</span><br><span class="line"><span class="comment">//make只指定长度</span></span><br><span class="line"><span class="keyword">var</span> slice1 []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>) <span class="comment">//type = int , len = 3时，slice1:[0,0,0]</span></span><br><span class="line"><span class="comment">//make还指定容量</span></span><br><span class="line"><span class="built_in">make</span>([]T, length, capacity)<span class="comment">//type = int , len = 3,capacity = 5时，slice1:[0,0,0, , ]</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>二维初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态二维数组的初始化</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>][<span class="number">4</span>]<span class="type">int</span> <span class="comment">//这里只能用常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动态二维切片的初始化 初始化一个n行m列的二维int切片</span></span><br><span class="line">matrix := <span class="built_in">make</span>([][]<span class="type">int</span>, n)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> matrix &#123;</span><br><span class="line">    matrix[i] = <span class="built_in">make</span>([]<span class="type">int</span>, m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维初始化</span></span><br><span class="line"><span class="keyword">var</span> matrix [][]<span class="type">int</span></span><br><span class="line">ret := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="切片截取-slice"><a href="#切片截取-slice" class="headerlink" title="切片截取:slice[:]"></a>切片截取:slice[:]</h3><p>和python的截取一样</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建切片 */</span></span><br><span class="line">numbers := []<span class="type">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;   </span><br><span class="line"><span class="comment">/* 打印子切片从索引1(包含) 到索引4(不包含)*/</span></span><br><span class="line">fmt.Println(<span class="string">&quot;numbers[1:4] ==&quot;</span>, numbers[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 默认下限为 0*/</span></span><br><span class="line">fmt.Println(<span class="string">&quot;numbers[:3] ==&quot;</span>, numbers[:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 默认上限为 len(s)*/</span></span><br><span class="line">fmt.Println(<span class="string">&quot;numbers[4:] ==&quot;</span>, numbers[<span class="number">4</span>:])</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="长度与容量：len-和-cap-函数"><a href="#长度与容量：len-和-cap-函数" class="headerlink" title="长度与容量：len() 和 cap() 函数"></a>长度与容量：len() 和 cap() 函数</h3><p>切片是可索引的，并且可以由 len() 方法获取长度。</p>
<p>切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。</p>
<h3 id="添加与拷贝：append-和-copy-函数"><a href="#添加与拷贝：append-和-copy-函数" class="headerlink" title="添加与拷贝：append() 和 copy() 函数"></a>添加与拷贝：append() 和 copy() 函数</h3><p><strong>apeend()</strong></p>
<p>切⽚的扩容机制，append的时候，如果⻓度增加后超过容量，则将容量增加2倍</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向切片添加一个元素 */</span></span><br><span class="line">numbers = <span class="built_in">append</span>(numbers, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 同时添加多个元素 */</span></span><br><span class="line">numbers = <span class="built_in">append</span>(numbers, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个切片合并</span></span><br><span class="line">num1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">num2 := []<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">numbers = <span class="built_in">append</span>(num1, num2...) <span class="comment">//...是展开运算符</span></span><br></pre></td></tr></table></figure>

<p><strong>copy()</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 拷贝 numbers 的内容到 numbers1 */</span></span><br><span class="line"><span class="built_in">copy</span>(numbers1,numbers)</span><br><span class="line"></span><br><span class="line"><span class="comment">//更推荐这种方式</span></span><br><span class="line">levelq = []<span class="type">int</span>&#123;&#125;<span class="comment">//清空后</span></span><br><span class="line">levelq = <span class="built_in">append</span>(levelq, childq...) <span class="comment">//再添加</span></span><br></pre></td></tr></table></figure>



<h3 id="传参-slice-int"><a href="#传参-slice-int" class="headerlink" title="传参:(slice []int)"></a>传参:(slice []int)</h3><p>动态数组在传参上是**引⽤传递(修改传递的值)**，⽽且不同元素⻓度的动态数组他们的形参是⼀致。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">myNum := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1e6</span>)</span><br><span class="line"><span class="comment">// 将 myNum 传递到函数 foo()</span></span><br><span class="line">slice = foo(myNum)</span><br><span class="line"><span class="comment">// 函数 foo() 接收一个整型切片，并返回这个切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(slice []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ix, value := <span class="keyword">range</span> slice1 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="slice去重"><a href="#slice去重" class="headerlink" title="slice去重"></a>slice去重</h3><p>在Go语言中，可以使用 map 实现 slice 去重。</p>
<ol>
<li>创建一个空的<code>map</code>，用于存放去重后的元素。</li>
<li>遍历<code>slice</code>中的元素，将元素作为<code>map</code>的键，值为<code>true</code>（可以是任意值，只要占用空间小）。</li>
<li>将<code>map</code>中的键转换为<code>slice</code>返回。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">func <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>&#125;</span><br><span class="line">    </span><br><span class="line">    result := make([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    temp := make(map[<span class="type">int</span>]bool)</span><br><span class="line">    <span class="keyword">for</span> _, v := range nums &#123;</span><br><span class="line">        <span class="keyword">if</span> !temp[v] &#123;</span><br><span class="line">            result = append(result, v)</span><br><span class="line">            temp[v] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(result) <span class="comment">// [1 2 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，在上面的代码中，value 值使用了空结构体 struct{}{}，而不是 nil。这是因为在 Go 语言中，map 中的 key 才是重要的，而 value 是无关紧要的。如果直接使用 nil 作为 value，会占用不必要的空间。因此，使用一个空结构体作为 value，既能够实现去重，又能够避免占用不必要的空间。</p>
<p><code>if !temp[v]</code> 表示如果 <code>temp</code> 列表中的索引 <code>v</code> 对应的值为 <code>false</code>，则执行条件语句。</p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>go分别提供了sort.Float64s() sort.Strings() sort.Ints() 对不同类型的数组进行排序</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort.Ints(nums)</span><br></pre></td></tr></table></figure>







<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>map就是存储key,value键值对的数据结构</p>
<h3 id="声明方式-make"><a href="#声明方式-make" class="headerlink" title="声明方式:make()"></a>声明方式:make()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种声明</span></span><br><span class="line"><span class="keyword">var</span> test1 <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line"><span class="comment">//在使用map前，需要先make，make的作用就是给map分配数据空间</span></span><br><span class="line">test1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">10</span>) </span><br><span class="line">test1[<span class="string">&quot;one&quot;</span>] = <span class="string">&quot;php&quot;</span></span><br><span class="line">test1[<span class="string">&quot;two&quot;</span>] = <span class="string">&quot;golang&quot;</span></span><br><span class="line">test1[<span class="string">&quot;three&quot;</span>] = <span class="string">&quot;java&quot;</span></span><br><span class="line">fmt.Println(test1) <span class="comment">//map[two:golang three:java one:php]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种声明</span></span><br><span class="line">test2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">test2[<span class="string">&quot;one&quot;</span>] = <span class="string">&quot;php&quot;</span></span><br><span class="line">test2[<span class="string">&quot;two&quot;</span>] = <span class="string">&quot;golang&quot;</span></span><br><span class="line">test2[<span class="string">&quot;three&quot;</span>] = <span class="string">&quot;java&quot;</span></span><br><span class="line">fmt.Println(test2) <span class="comment">//map[one:php two:golang three:java]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种声明</span></span><br><span class="line">test3 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">    <span class="string">&quot;one&quot;</span> : <span class="string">&quot;php&quot;</span>,</span><br><span class="line">    <span class="string">&quot;two&quot;</span> : <span class="string">&quot;golang&quot;</span>,</span><br><span class="line">    <span class="string">&quot;three&quot;</span> : <span class="string">&quot;java&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(test3) <span class="comment">//map[one:php two:golang three:java]</span></span><br></pre></td></tr></table></figure>

<p>嵌套声明的举例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子1</span></span><br><span class="line">language := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">language[<span class="string">&quot;php&quot;</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line">language[<span class="string">&quot;php&quot;</span>][<span class="string">&quot;id&quot;</span>] = <span class="string">&quot;1&quot;</span></span><br><span class="line">language[<span class="string">&quot;php&quot;</span>][<span class="string">&quot;desc&quot;</span>] = <span class="string">&quot;php是世界上最美的语言&quot;</span></span><br><span class="line">language[<span class="string">&quot;golang&quot;</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line">language[<span class="string">&quot;golang&quot;</span>][<span class="string">&quot;id&quot;</span>] = <span class="string">&quot;2&quot;</span></span><br><span class="line">language[<span class="string">&quot;golang&quot;</span>][<span class="string">&quot;desc&quot;</span>] = <span class="string">&quot;golang抗并发非常good&quot;</span></span><br><span class="line">fmt.Println(language) <span class="comment">//map[php:map[id:1 desc:php是世界上最美的语言] golang:map[id:2 desc:golang抗并发非常good]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例子2</span></span><br><span class="line">mp1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>)</span><br><span class="line">mp2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*[]<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<h3 id="增加与修改"><a href="#增加与修改" class="headerlink" title="增加与修改"></a>增加与修改</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m[k] = e</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><code>delete(m, k)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(language, <span class="string">&quot;php&quot;</span>)  <span class="comment">//删除了php子元素</span></span><br></pre></td></tr></table></figure>

<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val, ok := language[<span class="string">&quot;php&quot;</span>]  <span class="comment">//查找是否有php这个子元素</span></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">     fmt.Printf(<span class="string">&quot;%v&quot;</span>, val)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     fmt.Printf(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历-2"><a href="#遍历-2" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> map1 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">barVal = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;alpha&quot;</span>: <span class="number">34</span>, <span class="string">&quot;bravo&quot;</span>: <span class="number">56</span>, <span class="string">&quot;charlie&quot;</span>: <span class="number">23</span>,</span><br><span class="line">                        <span class="string">&quot;delta&quot;</span>: <span class="number">87</span>, <span class="string">&quot;echo&quot;</span>: <span class="number">56</span>, <span class="string">&quot;foxtrot&quot;</span>: <span class="number">12</span>,</span><br><span class="line">                        <span class="string">&quot;golf&quot;</span>: <span class="number">34</span>, <span class="string">&quot;hotel&quot;</span>: <span class="number">16</span>, <span class="string">&quot;indio&quot;</span>: <span class="number">87</span>,</span><br><span class="line">                        <span class="string">&quot;juliet&quot;</span>: <span class="number">65</span>, <span class="string">&quot;kili&quot;</span>: <span class="number">43</span>, <span class="string">&quot;lima&quot;</span>: <span class="number">98</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;unsorted:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> barVal &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Key: %v, Value: %v / &quot;</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line">keys := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(barVal))</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> k, _ := <span class="keyword">range</span> barVal &#123;</span><br><span class="line">    keys[i] = k</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(keys)</span><br><span class="line">fmt.Println()</span><br><span class="line">fmt.Println(<span class="string">&quot;sorted:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Key: %v, Value: %v / &quot;</span>, k, barVal[k])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="键值对反转"><a href="#键值对反转" class="headerlink" title="键值对反转"></a>键值对反转</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    barVal = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;alpha&quot;</span>: <span class="number">34</span>, <span class="string">&quot;bravo&quot;</span>: <span class="number">56</span>, <span class="string">&quot;charlie&quot;</span>: <span class="number">23</span>,</span><br><span class="line">                            <span class="string">&quot;delta&quot;</span>: <span class="number">87</span>, <span class="string">&quot;echo&quot;</span>: <span class="number">56</span>, <span class="string">&quot;foxtrot&quot;</span>: <span class="number">12</span>,</span><br><span class="line">                            <span class="string">&quot;golf&quot;</span>: <span class="number">34</span>, <span class="string">&quot;hotel&quot;</span>: <span class="number">16</span>, <span class="string">&quot;indio&quot;</span>: <span class="number">87</span>,</span><br><span class="line">                            <span class="string">&quot;juliet&quot;</span>: <span class="number">65</span>, <span class="string">&quot;kili&quot;</span>: <span class="number">43</span>, <span class="string">&quot;lima&quot;</span>: <span class="number">98</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    invMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>, <span class="built_in">len</span>(barVal))</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> barVal &#123;</span><br><span class="line">        invMap[v] = k</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;inverted:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> invMap &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Key: %v, Value: %v / &quot;</span>, k, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="结构体及其方法-面向对象的特征"><a href="#结构体及其方法-面向对象的特征" class="headerlink" title="结构体及其方法-面向对象的特征"></a>结构体及其方法-面向对象的特征</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>类名、属性名、⽅法名 ⾸字⺟⼤写表示对外(其他包)可以访问，否则只能够在本包内访问</p>
<h4 id="属性的定义"><a href="#属性的定义" class="headerlink" title="属性的定义"></a>属性的定义</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果类名首字母大写，表示其他包也能够访问</span></span><br><span class="line"><span class="keyword">type</span> Hero <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">//如果说类的属性首字母大写, 表示该属性是对外能够访问的，否则的话只能够类的内部访问</span></span><br><span class="line">	Name  <span class="type">string</span></span><br><span class="line">	Ad    <span class="type">int</span></span><br><span class="line">	level <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h4><p>需要加<code>*</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 不加*是错误写法，因为是值传递，所以无法修改成功</span></span><br><span class="line"><span class="comment">func (this Hero) SetName(newName string) &#123;</span></span><br><span class="line"><span class="comment">	//this 是调用该方法的对象的一个副本（拷贝）</span></span><br><span class="line"><span class="comment">	this.Name = newName</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Hero)</span></span> Show() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Name = &quot;</span>, this.Name)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Ad = &quot;</span>, this.Ad)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Level = &quot;</span>, this.level)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Hero)</span></span> GetName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this.Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Hero)</span></span> SetName(newName <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="comment">//this 是调用该方法的对象的一个副本（拷贝）</span></span><br><span class="line">	this.Name = newName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h4><p>大括号的形式进行实例化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个对象</span></span><br><span class="line">hero := Hero&#123;Name: <span class="string">&quot;zhang3&quot;</span>, Ad: <span class="number">100</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="父类的定义"><a href="#父类的定义" class="headerlink" title="父类的定义"></a>父类的定义</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	sex  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Human)</span></span> Eat() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Human.Eat()...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Human)</span></span> Walk() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Human.Walk()...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="子类的继承"><a href="#子类的继承" class="headerlink" title="子类的继承"></a>子类的继承</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SuperMan <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human <span class="comment">//SuperMan类继承了Human类的方法</span></span><br><span class="line"></span><br><span class="line">	level <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重定义父类的方法Eat()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *SuperMan)</span></span> Eat() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;SuperMan.Eat()...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类的新方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *SuperMan)</span></span> Fly() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;SuperMan.Fly()...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="子类的实例化"><a href="#子类的实例化" class="headerlink" title="子类的实例化"></a>子类的实例化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个子类对象</span></span><br><span class="line">s := SuperMan&#123;Human&#123;<span class="string">&quot;li4&quot;</span>, <span class="string">&quot;female&quot;</span>&#125;, <span class="number">88</span>&#125;</span><br><span class="line"><span class="comment">//var s SuperMan</span></span><br><span class="line"><span class="comment">//s.name = &quot;li4&quot;</span></span><br><span class="line"><span class="comment">//s.sex = &quot;male&quot;</span></span><br><span class="line"><span class="comment">//s.level = 88</span></span><br><span class="line"></span><br><span class="line">s.Walk() <span class="comment">//父类的方法</span></span><br><span class="line">s.Eat()  <span class="comment">//子类的方法</span></span><br><span class="line">s.Fly()  <span class="comment">//子类的方法</span></span><br></pre></td></tr></table></figure>



<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="多态的三要素"><a href="#多态的三要素" class="headerlink" title="多态的三要素"></a>多态的三要素</h4><ul>
<li>有⼀个⽗类(有接⼝)；</li>
<li>有⼦类(实现了⽗类的全部接⼝⽅法)；</li>
<li>⽗类类型的变量(指针) 指向(引⽤) ⼦类的具体数据变量</li>
</ul>
<p><strong>(1)有⼀个⽗类(有接⼝)</strong></p>
<p>接口定义了待实现的方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本质是一个指针</span></span><br><span class="line"><span class="keyword">type</span> AnimalIF <span class="keyword">interface</span> &#123;</span><br><span class="line">	Sleep()</span><br><span class="line">	GetColor() <span class="type">string</span> <span class="comment">//获取动物的颜色</span></span><br><span class="line">	GetType() <span class="type">string</span>  <span class="comment">//获取动物的种类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>(2)有⼦类(实现了⽗类的全部接⼝⽅法)</strong></p>
<p>只要子类实现了某接口的全部方法，就是该接口的子类</p>
<p>子类1</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体的类</span></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">	color <span class="type">string</span> <span class="comment">//猫的颜色</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Cat)</span></span> Sleep() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Cat is Sleep&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Cat)</span></span> GetColor() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this.color</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Cat)</span></span> GetType() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;Cat&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类2</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体的类</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	color <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Dog)</span></span> Sleep() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Dog is Sleep&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Dog)</span></span> GetColor() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this.color</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Dog)</span></span> GetType() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;Dog&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showAnimal</span><span class="params">(animal AnimalIF)</span></span> &#123;</span><br><span class="line">	animal.Sleep() <span class="comment">//多态</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;color = &quot;</span>, animal.GetColor())</span><br><span class="line">	fmt.Println(<span class="string">&quot;kind = &quot;</span>, animal.GetType())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(3)⽗类类型的变量(指针) 指向(引⽤) ⼦类的具体数据变量</strong></p>
<p>利用了多态性质的函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showAnimal</span><span class="params">(animal AnimalIF)</span></span> &#123;</span><br><span class="line">	animal.Sleep() <span class="comment">//多态</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;color = &quot;</span>, animal.GetColor())</span><br><span class="line">	fmt.Println(<span class="string">&quot;kind = &quot;</span>, animal.GetType())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用该函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animal AnimalIF <span class="comment">//接口的数据类型， 父类指针</span></span><br><span class="line">animal = &amp;Cat&#123;<span class="string">&quot;Green&quot;</span>&#125;</span><br><span class="line">animal.Sleep() <span class="comment">//调用的就是Cat的Sleep()方法 , 多态的现象</span></span><br><span class="line"></span><br><span class="line">animal = &amp;Dog&#123;<span class="string">&quot;Yellow&quot;</span>&#125;</span><br><span class="line">animal.Sleep() <span class="comment">// 调用Dog的Sleep方法，多态的现象</span></span><br><span class="line"></span><br><span class="line">cat := Cat&#123;<span class="string">&quot;Green&quot;</span>&#125;</span><br><span class="line">dog := Dog&#123;<span class="string">&quot;Yellow&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">showAnimal(&amp;cat)</span><br><span class="line">showAnimal(&amp;dog)</span><br></pre></td></tr></table></figure>

<h2 id="万能通用类：多态的最好体现"><a href="#万能通用类：多态的最好体现" class="headerlink" title="万能通用类：多态的最好体现"></a>万能通用类：多态的最好体现</h2><h3 id="interface-类"><a href="#interface-类" class="headerlink" title="interface{}类"></a>interface{}类</h3><p>类似python ,java里的 object类</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//interface&#123;&#125;是万能数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">(arg <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;myFunc is called...&quot;</span>)</span><br><span class="line">	fmt.Println(arg)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//interface&#123;&#125; 改如何区分 此时引用的底层数据类型到底是什么？</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//给 interface&#123;&#125; 提供 “类型断言” 的机制</span></span><br><span class="line">	value, ok := arg.(<span class="type">string</span>)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;arg is not string type&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;arg is string type, value = &quot;</span>, value)</span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">&quot;value type is %T\n&quot;</span>, value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">	auth <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	book := Book&#123;<span class="string">&quot;Golang&quot;</span>&#125;</span><br><span class="line">	myFunc(book)</span><br><span class="line">	myFunc(<span class="number">100</span>)</span><br><span class="line">	myFunc(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">	myFunc(<span class="number">3.14</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="类型断言机制"><a href="#类型断言机制" class="headerlink" title="类型断言机制"></a>类型断言机制</h3><p>写法举例：<code>value, ok := a.(string)</code></p>
<p>如果断言失败，那么ok的值将会是false,但是如果断言成功ok的值将会是true,同时value将会得到所期待的正确的值。示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">value, ok := a.(<span class="type">string</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;It&#x27;s not ok for type string&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;The value is &quot;</span>, value)</span><br></pre></td></tr></table></figure>



<h1 id="四、应用级编程"><a href="#四、应用级编程" class="headerlink" title="四、应用级编程"></a>四、应用级编程</h1><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h3 id="线程与协程简介"><a href="#线程与协程简介" class="headerlink" title="线程与协程简介"></a>线程与协程简介</h3><p><strong>操作的是线程</strong>：由于进程是占用系统资源的，而进程不是，所以调度的基本单位一般是线程。下图显示了线程与进程之间的消耗不同。</p>
<img src="https://gitee.com/yushen611/img/raw/master/image-20230318203926697.png" alt="image-20230318203926697" style="zoom:67%;">



<p><strong>把线程拆分成内核线程和用户线程</strong>：对于cpu来说，内核的操作不变，用户线程去处理业务逻辑。</p>
<p><img src="https://gitee.com/yushen611/img/raw/master/image-20230318204057735.png" alt="image-20230318204057735"></p>
<p>因此，分别取个名称为**(内核)线程与协程**:</p>
<img src="https://gitee.com/yushen611/img/raw/master/image-20230318204306210.png" alt="image-20230318204306210" style="zoom:67%;">

<p>线程与协程的初代模型 <strong>N：1模型</strong>：这种模型一旦某一个协程阻塞了，后面的协程就无法执行</p>
<p><img src="https://gitee.com/yushen611/img/raw/master/image-20230318204631254.png" alt="image-20230318204631254"></p>
<p>线程与协程的<strong>M：N模型</strong>：这样只有优化协程调度器即可</p>
<img src="https://gitee.com/yushen611/img/raw/master/image-20230318204803501.png" alt="image-20230318204803501" style="zoom:80%;">



<h3 id="GMP模型简介"><a href="#GMP模型简介" class="headerlink" title="GMP模型简介"></a>GMP模型简介</h3><h4 id="go语言对协程的实现"><a href="#go语言对协程的实现" class="headerlink" title="go语言对协程的实现"></a><strong>go语言对协程的实现</strong></h4><p>使用goruntine实现</p>
<img src="https://gitee.com/yushen611/img/raw/master/image-20230318204939721.png" alt="image-20230318204939721" style="zoom:67%;">

<p><strong>go语言中的协程调度模型：GMP模型</strong></p>
<p>符号及其意义</p>
<img src="https://gitee.com/yushen611/img/raw/master/image-20230318205048675.png" alt="image-20230318205048675" style="zoom:80%;">

<p>注：M是machine的意思</p>
<h4 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h4><p><strong>原理图如下</strong>：</p>
<p><img src="https://gitee.com/yushen611/img/raw/master/image-20230318205210487.png" alt="image-20230318205210487"></p>
<p>注：<code>并行</code>数量由GOMAXPROCS个数觉得</p>
<h4 id="调度策略：working-stealing机制"><a href="#调度策略：working-stealing机制" class="headerlink" title="调度策略：working stealing机制"></a><strong>调度策略：working stealing机制</strong></h4><p>如果第一个调度器中的本地队友还有协程：</p>
<p><img src="https://gitee.com/yushen611/img/raw/master/image-20230318205430210.png" alt="image-20230318205430210"></p>
<p>其余的空调度器会把其他调度器管理的协程偷过去执行：</p>
<img src="https://gitee.com/yushen611/img/raw/master/image-20230318205548863.png" alt="image-20230318205548863" style="zoom:80%;">

<h4 id="调度策略：hand-off机制"><a href="#调度策略：hand-off机制" class="headerlink" title="调度策略：hand off机制"></a><strong>调度策略：hand off机制</strong></h4><p>当协程阻塞时</p>
<img src="https://gitee.com/yushen611/img/raw/master/image-20230318205729936.png" alt="image-20230318205729936" style="zoom:80%;">

<p>会创建一个新线程，把阻塞线程的调度器管理的协程队列迁移到新的线程上</p>
<img src="https://gitee.com/yushen611/img/raw/master/image-20230318205915554.png" alt="image-20230318205915554" style="zoom:80%;">



<h3 id><a href="#" class="headerlink" title></a></h3>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2021/08/15/hello/" rel="next" title="Welcome to visit my blog.">
      Welcome to visit my blog. <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#golang%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">golang基础教程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81golang%E7%AE%80%E4%BB%8B"><span class="nav-number">2.</span> <span class="nav-text">一、golang简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#go%E8%AF%AD%E8%A8%80%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">2.1.</span> <span class="nav-text">go语言的优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8A%BF"><span class="nav-number">2.1.1.</span> <span class="nav-text">优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E5%90%88%E6%96%B9%E5%90%91"><span class="nav-number">2.1.2.</span> <span class="nav-text">适合方向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%83%BD%E7%BC%BA%E7%82%B9"><span class="nav-number">2.1.3.</span> <span class="nav-text">可能缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#go%E7%9A%84%E5%AE%89%E8%A3%85"><span class="nav-number">2.2.</span> <span class="nav-text">go的安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E4%B8%8E%E6%A3%80%E6%B5%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">2.2.1.</span> <span class="nav-text">下载安装与检测环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%9AGOPROXY"><span class="nav-number">2.2.2.</span> <span class="nav-text">配置环境变量：GOPROXY</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%9AGO111MODULE"><span class="nav-number">2.2.3.</span> <span class="nav-text">配置环境变量：GO111MODULE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%9AGOPATH-%E5%92%8C-GOROOT"><span class="nav-number">2.2.4.</span> <span class="nav-text">查看环境变量：GOPATH 和 GOROOT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GOROOT"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">GOROOT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GOPATH"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">GOPATH</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#go%E7%9A%84hello-world"><span class="nav-number">2.3.</span> <span class="nav-text">go的hello world</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E6%9C%80%E7%AE%80hello-world%E4%BB%A3%E7%A0%81"><span class="nav-number">2.3.1.</span> <span class="nav-text">编写最简hello world代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E5%A4%9A%E5%8C%85hello-world"><span class="nav-number">2.3.2.</span> <span class="nav-text">编写多包hello world</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#go%E8%AF%AD%E6%B3%95%E7%89%B9%E8%89%B2%E6%80%BB%E7%BB%93"><span class="nav-number">2.3.3.</span> <span class="nav-text">go语法特色总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#go%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">2.4.</span> <span class="nav-text">go的常用命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C"><span class="nav-number">2.4.1.</span> <span class="nav-text">编译与运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">2.4.2.</span> <span class="nav-text">查看环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81"><span class="nav-number">2.4.3.</span> <span class="nav-text">格式化代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#go%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E6%A0%87%E8%AF%86%E7%AC%A6%E7%AE%80%E4%BB%8B"><span class="nav-number">2.5.</span> <span class="nav-text">go的关键字与标识符简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#go%E7%9A%8425%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.5.1.</span> <span class="nav-text">go的25个关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-number">2.5.2.</span> <span class="nav-text">标识符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">二、数据与方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.1.</span> <span class="nav-text">数据的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.1.1.</span> <span class="nav-text">数据的基本类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Go%E6%94%AF%E6%8C%81%E7%9A%84%E5%86%85%E7%BD%AE%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">Go支持的内置基本类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B0%BA%E5%AF%B8"><span class="nav-number">3.1.1.2.</span> <span class="nav-text">内置基本类型的尺寸</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9B%B6%E5%80%BC"><span class="nav-number">3.1.1.3.</span> <span class="nav-text">内置基本类型的零值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%97%E9%9D%A2%E9%87%8F%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F"><span class="nav-number">3.1.1.4.</span> <span class="nav-text">基本类型的字面量表示形式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%98%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.1.2.</span> <span class="nav-text">类型的显式类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E4%B8%8D%E7%A1%AE%E5%AE%9A%E5%80%BC"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">类型不确定值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">显式类型转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">3.1.3.</span> <span class="nav-text">数据运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-number">3.1.4.</span> <span class="nav-text">指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%8D%E7%A7%B0"><span class="nav-number">3.1.5.</span> <span class="nav-text">自定义数据类型名称</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">3.2.</span> <span class="nav-text">变量的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">3.2.1.</span> <span class="nav-text">单变量的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">3.2.2.</span> <span class="nav-text">多变量的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="nav-number">3.2.3.</span> <span class="nav-text">局部变量与全局变量的说明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">3.3.</span> <span class="nav-text">常量的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%A4%9A%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">3.3.1.</span> <span class="nav-text">单常量与多常量定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E5%B8%B8%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">3.3.2.</span> <span class="nav-text">枚举常量的定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">3.4.</span> <span class="nav-text">函数的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">3.4.1.</span> <span class="nav-text">简单介绍与注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">3.4.2.</span> <span class="nav-text">函数的参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92-VS-%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">按值传递 VS 按引用传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E9%80%92%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">传递变长参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">3.4.3.</span> <span class="nav-text">函数的返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.4.4.</span> <span class="nav-text">函数作为数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0-%E5%8F%88%E7%A7%B0%E4%B8%BA%E9%97%AD%E5%8C%85"><span class="nav-number">3.4.5.</span> <span class="nav-text">匿名函数(又称为闭包)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="nav-number">3.4.6.</span> <span class="nav-text">内置函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%80%E5%87%BA%E9%98%B6%E6%AE%B5%EF%BC%9Adefer%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">3.4.7.</span> <span class="nav-text">函数的退出阶段：defer关键字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E6%B3%95"><span class="nav-number">3.5.</span> <span class="nav-text">基本流程控制语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#if-else%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E6%8E%A7%E5%88%B6%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">3.5.1.</span> <span class="nav-text">if-else条件分支控制代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for%E5%BE%AA%E7%8E%AF%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">3.5.2.</span> <span class="nav-text">for循环代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch-case%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">3.5.3.</span> <span class="nav-text">switch-case流程控制代码块</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">三、数据结构与算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E5%BC%95%E5%85%A5%E4%B8%8E%E5%8C%85%E7%AE%A1%E7%90%86"><span class="nav-number">4.1.</span> <span class="nav-text">包引入与包管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E5%BC%95%E5%85%A5"><span class="nav-number">4.1.1.</span> <span class="nav-text">包引入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%85%E5%BC%95%E5%85%A5%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">包引入的方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%85%E5%BC%95%E5%85%A5%E6%97%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9A%E5%8C%85%E7%9A%84init%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">包引入时的执行顺序：包的init函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E7%AE%A1%E7%90%86"><span class="nav-number">4.1.2.</span> <span class="nav-text">包管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%80%81%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%EF%BC%9AGOPATH"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">老的包管理：GOPATH</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%EF%BC%9AGo-Modules"><span class="nav-number">4.1.2.2.</span> <span class="nav-text">新的包管理：Go Modules</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#go-mod%E5%91%BD%E4%BB%A4"><span class="nav-number">4.1.2.2.1.</span> <span class="nav-text">go mod命令</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">4.2.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86"><span class="nav-number">4.2.0.1.</span> <span class="nav-text">遍历</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%87%E7%89%87"><span class="nav-number">4.3.</span> <span class="nav-text">切片</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96-make"><span class="nav-number">4.3.1.</span> <span class="nav-text">定义与初始化:make()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E7%89%87%E6%88%AA%E5%8F%96-slice"><span class="nav-number">4.3.2.</span> <span class="nav-text">切片截取:slice[:]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%BF%E5%BA%A6%E4%B8%8E%E5%AE%B9%E9%87%8F%EF%BC%9Alen-%E5%92%8C-cap-%E5%87%BD%E6%95%B0"><span class="nav-number">4.3.3.</span> <span class="nav-text">长度与容量：len() 和 cap() 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%8B%B7%E8%B4%9D%EF%BC%9Aappend-%E5%92%8C-copy-%E5%87%BD%E6%95%B0"><span class="nav-number">4.3.4.</span> <span class="nav-text">添加与拷贝：append() 和 copy() 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E5%8F%82-slice-int"><span class="nav-number">4.3.5.</span> <span class="nav-text">传参:(slice []int)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86-1"><span class="nav-number">4.3.6.</span> <span class="nav-text">遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slice%E5%8E%BB%E9%87%8D"><span class="nav-number">4.3.7.</span> <span class="nav-text">slice去重</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">4.3.8.</span> <span class="nav-text">排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%A0%E5%B0%84"><span class="nav-number">4.4.</span> <span class="nav-text">映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F-make"><span class="nav-number">4.4.1.</span> <span class="nav-text">声明方式:make()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A2%9E%E5%8A%A0%E4%B8%8E%E4%BF%AE%E6%94%B9"><span class="nav-number">4.4.2.</span> <span class="nav-text">增加与修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4"><span class="nav-number">4.4.3.</span> <span class="nav-text">删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE"><span class="nav-number">4.4.4.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86-2"><span class="nav-number">4.4.5.</span> <span class="nav-text">遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F-1"><span class="nav-number">4.4.6.</span> <span class="nav-text">排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%AE%E5%80%BC%E5%AF%B9%E5%8F%8D%E8%BD%AC"><span class="nav-number">4.4.7.</span> <span class="nav-text">键值对反转</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81"><span class="nav-number">4.5.</span> <span class="nav-text">结构体及其方法-面向对象的特征</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">4.5.1.</span> <span class="nav-text">封装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">4.5.1.1.</span> <span class="nav-text">属性的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">4.5.1.2.</span> <span class="nav-text">方法的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">4.5.1.3.</span> <span class="nav-text">对象实例化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">4.5.2.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%88%B6%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">4.5.2.1.</span> <span class="nav-text">父类的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%90%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="nav-number">4.5.2.2.</span> <span class="nav-text">子类的继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%90%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">4.5.2.3.</span> <span class="nav-text">子类的实例化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">4.5.3.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="nav-number">4.5.3.1.</span> <span class="nav-text">多态的三要素</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%87%E8%83%BD%E9%80%9A%E7%94%A8%E7%B1%BB%EF%BC%9A%E5%A4%9A%E6%80%81%E7%9A%84%E6%9C%80%E5%A5%BD%E4%BD%93%E7%8E%B0"><span class="nav-number">4.6.</span> <span class="nav-text">万能通用类：多态的最好体现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#interface-%E7%B1%BB"><span class="nav-number">4.6.1.</span> <span class="nav-text">interface{}类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E6%9C%BA%E5%88%B6"><span class="nav-number">4.6.2.</span> <span class="nav-text">类型断言机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%BA%94%E7%94%A8%E7%BA%A7%E7%BC%96%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">四、应用级编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-number">5.1.</span> <span class="nav-text">并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B%E7%AE%80%E4%BB%8B"><span class="nav-number">5.1.1.</span> <span class="nav-text">线程与协程简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GMP%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B"><span class="nav-number">5.1.2.</span> <span class="nav-text">GMP模型简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#go%E8%AF%AD%E8%A8%80%E5%AF%B9%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.1.2.1.</span> <span class="nav-text">go语言对协程的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="nav-number">5.1.2.2.</span> <span class="nav-text">原理图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%EF%BC%9Aworking-stealing%E6%9C%BA%E5%88%B6"><span class="nav-number">5.1.2.3.</span> <span class="nav-text">调度策略：working stealing机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%EF%BC%9Ahand-off%E6%9C%BA%E5%88%B6"><span class="nav-number">5.1.2.4.</span> <span class="nav-text">调度策略：hand off机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">5.1.3.</span> <span class="nav-text"></span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="WenYa Yu"
      src="/images/myPhoto.jpg">
  <p class="site-author-name" itemprop="name">WenYa Yu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WenYa Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":"fasle"},"log":false});</script></body>
</html>
