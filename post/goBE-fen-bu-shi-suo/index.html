<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>åˆ†å¸ƒå¼é”-åŸºäºredisæˆ–åŸºäºmysqlçš„goè¯­è¨€å®ç° | YU WENYA&#39;S BLOG</title>
<link rel="shortcut icon" href="https://yushen611.github.io/favicon.ico?v=1694708085062">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://yushen611.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="åˆ†å¸ƒå¼é”-åŸºäºredisæˆ–åŸºäºmysqlçš„goè¯­è¨€å®ç° | YU WENYA&#39;S BLOG - Atom Feed" href="https://yushen611.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="
ä¸€ã€åˆ†å¸ƒå¼é”çš„æ¦‚å¿µ
æ¦‚å¿µ
åˆ†å¸ƒå¼é”æ˜¯ä¸€ç§åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­å®ç°äº’æ–¥æ§åˆ¶çš„æŠ€æœ¯ã€‚å®ƒå¯ä»¥ä¿è¯åœ¨å¤šä¸ªçº¿ç¨‹æˆ–è€…å¤šå°æœåŠ¡å™¨åŒæ—¶è®¿é—®å…±äº«èµ„æºæ—¶ï¼Œåªæœ‰ä¸€ä¸ªçº¿ç¨‹æˆ–æœåŠ¡å™¨èƒ½å¤Ÿè·å¾—é”å¹¶å¯¹èµ„æºè¿›è¡Œæ“ä½œï¼Œå…¶ä»–çº¿ç¨‹æˆ–æœåŠ¡å™¨éœ€è¦ç­‰å¾…é”çš„é‡Šæ”¾æ‰èƒ½ç»§ç»­è®¿é—®ã€‚åˆ†å¸ƒå¼é”ä¸€èˆ¬ä½¿ç”¨..." />
    <meta name="keywords" content="go" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://yushen611.github.io">
  <img class="avatar" src="https://yushen611.github.io/images/avatar.png?v=1694708085062" alt="">
  </a>
  <h1 class="site-title">
    YU WENYA&#39;S BLOG
  </h1>
  <p class="site-description">
    ğŸ‘  æ¬¢è¿æ¥åˆ°ä½™æ–‡æ¶¯çš„åšå®¢ ï¼  <br>
âœï¸  è¿™é‡Œå°†åˆ†äº«æœ‰å…³åŒºå—é“¾/åˆ†å¸ƒå¼ç³»ç»Ÿ/golangå¼€å‘/pythonæœºå™¨å­¦ä¹ ä¸æ•°æ®åˆ†æ/redis/mysql/é¢è¯•å…«è‚¡/leetcodåˆ·é¢˜ ç­‰é¢è¯•ä¸æŠ€æœ¯çŸ¥è¯†ã€‚
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          é¦–é¡µ
        </a>
      
    
      
        <a href="/archives" class="menu">
          å½’æ¡£
        </a>
      
    
      
        <a href="/tags" class="menu">
          æ ‡ç­¾
        </a>
      
    
      
        <a href="/post/about" class="menu">
          å…³äº
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/yushen611" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              åˆ†å¸ƒå¼é”-åŸºäºredisæˆ–åŸºäºmysqlçš„goè¯­è¨€å®ç°
            </h2>
            <div class="post-info">
              <span>
                2023-06-19
              </span>
              <span>
                14 min read
              </span>
              
                <a href="https://yushen611.github.io/tag/TNz53VXY2/" class="post-tag">
                  # go
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <meta name="referrer" content="no-referrer"/>
<h1 id="ä¸€-åˆ†å¸ƒå¼é”çš„æ¦‚å¿µ">ä¸€ã€åˆ†å¸ƒå¼é”çš„æ¦‚å¿µ</h1>
<h2 id="æ¦‚å¿µ">æ¦‚å¿µ</h2>
<p>åˆ†å¸ƒå¼é”æ˜¯ä¸€ç§åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­å®ç°äº’æ–¥æ§åˆ¶çš„æŠ€æœ¯ã€‚å®ƒå¯ä»¥ä¿è¯åœ¨å¤šä¸ªçº¿ç¨‹æˆ–è€…å¤šå°æœåŠ¡å™¨åŒæ—¶è®¿é—®å…±äº«èµ„æºæ—¶ï¼Œåªæœ‰ä¸€ä¸ªçº¿ç¨‹æˆ–æœåŠ¡å™¨èƒ½å¤Ÿè·å¾—é”å¹¶å¯¹èµ„æºè¿›è¡Œæ“ä½œï¼Œå…¶ä»–çº¿ç¨‹æˆ–æœåŠ¡å™¨éœ€è¦ç­‰å¾…é”çš„é‡Šæ”¾æ‰èƒ½ç»§ç»­è®¿é—®ã€‚åˆ†å¸ƒå¼é”ä¸€èˆ¬ä½¿ç”¨ä¸€äº›å…±äº«å­˜å‚¨ç³»ç»Ÿï¼ˆå¦‚Redisã€Zookeeperç­‰ï¼‰æä¾›çš„åŸå­æ“ä½œå®ç°ï¼Œæ¯”å¦‚setnxæ“ä½œã€CASæ“ä½œç­‰ã€‚è¿™æ ·å°±å¯ä»¥é¿å…å¤šä¸ªçº¿ç¨‹æˆ–æœåŠ¡å™¨åœ¨åŒä¸€æ—¶é—´åŒæ—¶è®¿é—®å…±äº«èµ„æºå¯¼è‡´æ•°æ®å‡ºé”™çš„é—®é¢˜ã€‚</p>
<h2 id="ä¸¾ä¾‹">ä¸¾ä¾‹</h2>
<p>å‡è®¾æœ‰ä¸€ä¸ªåœ¨çº¿æŠ½å¥–ç³»ç»Ÿï¼Œå¤šä¸ªç”¨æˆ·åŒæ—¶è¿›å…¥é¡µé¢æƒ³è¦å‚ä¸æŠ½å¥–ï¼Œä½†æ˜¯ç³»ç»Ÿåªèƒ½å…è®¸ä¸€ä¸ªç”¨æˆ·æŠ½å¥–ï¼Œå…¶ä»–ç”¨æˆ·éœ€è¦ç­‰å¾…å‰ä¸€ä¸ªç”¨æˆ·ä¸­å¥–åæ‰èƒ½å†æ¬¡æŠ½å¥–ã€‚è¿™æ—¶å€™å°±éœ€è¦ç”¨åˆ°åˆ†å¸ƒå¼é”æ¥å®ç°ã€‚</p>
<p>åˆ†å¸ƒå¼é”çš„å®ç°æ–¹å¼å¯ä»¥æ˜¯åŸºäºå…±äº«å­˜å‚¨ç³»ç»Ÿï¼Œä¾‹å¦‚Redisã€‚å‡å¦‚å¤šä¸ªç”¨æˆ·åŒæ—¶å‘èµ·è¯·æ±‚ï¼Œç³»ç»Ÿå¯ä»¥å…ˆåœ¨Redisä¸­åˆ›å»ºä¸€ä¸ªåä¸ºâ€œlottery_lockâ€çš„é”®å€¼å¯¹ï¼Œè®¾ç½®è¿‡æœŸæ—¶é—´ä¸º5ç§’ï¼Œç„¶åé€šè¿‡setnxæ“ä½œå°è¯•è·å–è¿™ä¸ªé”®çš„é”ã€‚å¦‚æœè·å–åˆ°é”ï¼Œå…¶ä¸­ä¸€ä¸ªç”¨æˆ·å°±å¯ä»¥è¿›è¡ŒæŠ½å¥–ï¼ŒæŠ½å®Œå¥–åå†é€šè¿‡delæ“ä½œæˆ–è€…è®¾ç½®è¿‡æœŸæ—¶é—´æ¥é‡Šæ”¾é”ã€‚å¦‚æœæ²¡æœ‰è·å–åˆ°é”ï¼Œä»£ç éœ€è¦ç­‰å¾…ï¼Œå¹¶ä¸”åœ¨ç­‰å¾…è¿‡ç¨‹ä¸­å®šæ—¶åˆ·æ–°è¿‡æœŸæ—¶é—´ã€‚</p>
<p>å› ä¸ºRedisæ˜¯ä¸€ä¸ªå•çº¿ç¨‹å¤„ç†è¯·æ±‚çš„ç³»ç»Ÿï¼Œæ‰€ä»¥setnxå’Œdelæ“ä½œéƒ½æ˜¯åŸå­æ€§æ“ä½œï¼Œå¯ä»¥ä¿è¯èµ„æºåœ¨åˆ†å¸ƒå¼ç¯å¢ƒä¸‹è¢«æ­£ç¡®åœ°å ç”¨å’Œé‡Šæ”¾ã€‚</p>
<p>è¿™å°±æ˜¯ä¸€ä¸ªç®€å•çš„ä½¿ç”¨åˆ†å¸ƒå¼é”çš„ä¾‹å­ï¼Œå®ƒå¯ä»¥ç¡®ä¿åœ¨çº¿æŠ½å¥–ç³»ç»Ÿåœ¨å¤šç”¨æˆ·åŒæ—¶å‚ä¸æ—¶ï¼Œåªæœ‰ä¸€ä¸ªç”¨æˆ·èƒ½å¤Ÿä¸­å¥–ã€‚</p>
<h1 id="äºŒ-åŸºäºredisçš„å®ç°">äºŒã€åŸºäºredisçš„å®ç°</h1>
<blockquote>
<p>æºç å·²åœ¨githubä¸Šåˆ†äº«:<a href="https://github.com/yushen611/StudyDemo/tree/main/distributedLock">StudyDemo/distributedLock at main Â· yushen611/StudyDemo (github.com)</a></p>
</blockquote>
<h2 id="0å…¨éƒ¨ä»£ç ">0.å…¨éƒ¨ä»£ç </h2>
<p>æ‰€æœ‰ä»£ç éƒ½åœ¨ä¸€ä¸ªmain.goæ–‡ä»¶é‡Œ</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;sync&quot;
	&quot;time&quot;

	&quot;github.com/go-redis/redis&quot;
)

var (
	redisClient *redis.Client
	once        sync.Once
)

func GetRedis() *redis.Client {
	once.Do(func() {
		redisClient = initRedis()
	})
	return redisClient
}

func initRedis() *redis.Client {
	client := redis.NewClient(&amp;redis.Options{
		Addr:     &quot;localhost:6379&quot;,
		Password: &quot;&quot;, //No password set
		DB:       0,  // Use default DB
	})

	return client
}

const (
	lockExpire = 10 * time.Second // é”çš„è¶…æ—¶æ—¶é—´
	lockValue  = &quot;1&quot;              // é”çš„å†…å®¹
)

func acquireLock(lockName string, timeout time.Duration) bool {
	/*
		å°†lockKeyä½œä¸ºé”çš„åç§°ï¼ŒlockValueä½œä¸ºé”çš„å€¼ï¼ŒlockExpireä½œä¸ºé”çš„è¶…æ—¶æ—¶é—´ã€‚
		å¦‚æœSetNXå‘½ä»¤è¿”å›1ï¼Œè¯´æ˜æˆåŠŸåœ°è®¾ç½®äº†é”®å€¼å¯¹ï¼Œå¹¶ä¸”è¿™ä¸ªé”è¢«å½“å‰è¯·æ±‚çš„å®¢æˆ·ç«¯è·å–ï¼Œ
		å¦‚æœSetNXå‘½ä»¤è¿”å›0ï¼Œè¯´æ˜å½“å‰é”å·²ç»è¢«å…¶ä»–å®¢æˆ·ç«¯è·å–ï¼Œè¯·æ±‚çš„è¿™ä¸ªå®¢æˆ·ç«¯æ²¡æœ‰è·å–æˆåŠŸã€‚
	*/
	startTime := time.Now()
	for {
		result, err := GetRedis().SetNX(lockName, lockValue, lockExpire).Result()
		if err == nil &amp;&amp; result == true {
			return true
		}
		if timeout &gt; 0 &amp;&amp; time.Now().Sub(startTime) &gt; timeout {
			return false
		}
		time.Sleep(time.Millisecond * 100)
	}

}

func releaseLock(lockName string) bool {
	result, err := GetRedis().Del(lockName).Result()
	if err != nil || result == 0 {
		return false
	}
	return true
}

// ç¤ºä¾‹ä»£ç 
func main() {

	const lockKey = &quot;mylock&quot; // é”çš„åç§°
	if acquireLock(lockKey, time.Second*1) {
		// æ‰§è¡Œéœ€è¦åŠ é”çš„ä»£ç 
		fmt.Println(&quot;DO SOMETHING&quot;)
		defer releaseLock(lockKey)
	} else {
		// æœªè·å–åˆ°é”
		fmt.Println(&quot;Failed to acquire lock&quot;)
	}

}

</code></pre>
<h2 id="1ä¸redisè¿æ¥">1.ä¸redisè¿æ¥</h2>
<p>è¿™é‡Œé‡‡ç”¨å•ä¾‹æ¨¡å¼ä¸redisè¿æ¥</p>
<pre><code class="language-go">var (
	redisClient *redis.Client
	once        sync.Once
)

func GetRedis() *redis.Client {
	once.Do(func() {
		redisClient = initRedis()
	})
	return redisClient
}

func initRedis() *redis.Client {
	client := redis.NewClient(&amp;redis.Options{
		Addr:     &quot;localhost:6379&quot;,
		Password: &quot;&quot;, //No password set
		DB:       0,  // Use default DB
	})

	return client
}
</code></pre>
<h2 id="2è·å–é”æ“ä½œä¸é‡Šæ”¾é”æ“ä½œ">2.è·å–é”æ“ä½œä¸é‡Šæ”¾é”æ“ä½œ</h2>
<p>è·å–é”æ“ä½œæ˜¯åŸºäºredisçš„SetNXåŠŸèƒ½ï¼Œå¯ä»¥å®ç°åŸå­åŒ–æ“ä½œï¼Œä¸”åœ¨è®¾ç½®key,valueçš„åŒæ—¶å¯ä»¥è®¾ç½®è·å–æ—¶é—´ã€‚å¦‚æœé”è¿‡æœŸäº†ï¼Œåœ¨redisé‡Œå°±ä¼šè‡ªåŠ¨åˆ é™¤ï¼Œredisè¿™ä¸€ç‰¹æ€§é¿å…äº†æ‰‹åŠ¨åˆ é™¤è¿‡æœŸçš„é”çš„éº»çƒ¦ã€‚</p>
<p>åŒæ—¶ï¼Œè·å–é”å¹¶ä¸æ˜¯åªè·å–ä¸€æ¬¡è€Œæ˜¯è·å–å¤šæ¬¡ï¼Œå¼•å…¥äº†è¶…æ—¶æœºåˆ¶ã€‚å¦‚æœåœ¨è§„å®šæ—¶é—´å†…æ²¡æœ‰è·å–æˆåŠŸï¼Œæ‰æ”¾å¼ƒè·å–ã€‚</p>
<pre><code class="language-go">const (
	lockExpire = 10 * time.Second // é”çš„è¶…æ—¶æ—¶é—´
	lockValue  = &quot;1&quot;              // é”çš„å†…å®¹
)

func acquireLock(lockName string, timeout time.Duration) bool {
	/*
		å°†lockKeyä½œä¸ºé”çš„åç§°ï¼ŒlockValueä½œä¸ºé”çš„å€¼ï¼ŒlockExpireä½œä¸ºé”çš„è¶…æ—¶æ—¶é—´ã€‚
		å¦‚æœSetNXå‘½ä»¤è¿”å›1ï¼Œè¯´æ˜æˆåŠŸåœ°è®¾ç½®äº†é”®å€¼å¯¹ï¼Œå¹¶ä¸”è¿™ä¸ªé”è¢«å½“å‰è¯·æ±‚çš„å®¢æˆ·ç«¯è·å–ï¼Œ
		å¦‚æœSetNXå‘½ä»¤è¿”å›0ï¼Œè¯´æ˜å½“å‰é”å·²ç»è¢«å…¶ä»–å®¢æˆ·ç«¯è·å–ï¼Œè¯·æ±‚çš„è¿™ä¸ªå®¢æˆ·ç«¯æ²¡æœ‰è·å–æˆåŠŸã€‚
	*/
	startTime := time.Now()
	for {
		result, err := GetRedis().SetNX(lockName, lockValue, lockExpire).Result()
		if err == nil &amp;&amp; result == true {
			return true
		}
		if timeout &gt; 0 &amp;&amp; time.Now().Sub(startTime) &gt; timeout {
			return false
		}
		time.Sleep(time.Millisecond * 100)
	}

}

func releaseLock(lockName string) bool {
	result, err := GetRedis().Del(lockName).Result()
	if err != nil || result == 0 {
		return false
	}
	return true
}
</code></pre>
<h2 id="3ä½¿ç”¨çš„å®ä¾‹ä»£ç ">3.ä½¿ç”¨çš„å®ä¾‹ä»£ç </h2>
<pre><code class="language-go">// ç¤ºä¾‹ä»£ç 
func main() {

	const lockKey = &quot;mylock&quot; // é”çš„åç§°
	if acquireLock(lockKey, time.Second*1) {
		// æ‰§è¡Œéœ€è¦åŠ é”çš„ä»£ç 
		fmt.Println(&quot;DO SOMETHING&quot;)
		defer releaseLock(lockKey)
	} else {
		// æœªè·å–åˆ°é”
		fmt.Println(&quot;Failed to acquire lock&quot;)
	}

}
</code></pre>
<h1 id="ä¸‰-åŸºäºmysqlå®ç°">ä¸‰ã€åŸºäºmysqlå®ç°</h1>
<blockquote>
<p>æºç å·²åœ¨githubä¸Šåˆ†äº«:<a href="https://github.com/yushen611/StudyDemo/tree/main/distributedLock">StudyDemo/distributedLock at main Â· yushen611/StudyDemo (github.com)</a></p>
</blockquote>
<p>åŸºäºmysqlå®ç°ä¸redisçš„å”¯ä¸€ä¸åŒæ˜¯ï¼Œmysqléœ€è¦æ‰‹åŠ¨åˆ é™¤è¿‡æœŸçš„é”ã€‚</p>
<h2 id="0å…¨éƒ¨ä»£ç -2">0.å…¨éƒ¨ä»£ç </h2>
<p>æ‰€æœ‰ä»£ç éƒ½åœ¨ä¸€ä¸ªmain.goæ–‡ä»¶é‡Œ</p>
<pre><code class="language-go">package main

import (
	&quot;errors&quot;
	&quot;fmt&quot;
	&quot;path/filepath&quot;
	&quot;sync&quot;
	&quot;time&quot;

	&quot;gorm.io/driver/mysql&quot;
	&quot;gorm.io/gorm&quot;
)

var (
	db   *gorm.DB
	once sync.Once
)

func GetDB() *gorm.DB {
	once.Do(func() {
		db = initDB()
	})
	return db
}

func initDB() *gorm.DB {

	var user string = &quot;root&quot;
	var password string = &quot;123456&quot;
	var host string = &quot;localhost&quot;
	var port string = &quot;3306&quot;
	var dbname string = &quot;offermaker&quot;
	var Dsn = fmt.Sprintf(&quot;%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;,
		user,
		password,
		host,
		port,
		filepath.Join(dbname),
	)

	DB, err := gorm.Open(mysql.Open(Dsn), &amp;gorm.Config{})
	if err != nil {
		panic(&quot;failed to connect database, error=&quot; + err.Error())
	}
	fmt.Println(&quot;successfully connect database&quot;)

	return DB
}

const (
	LOCK_EXPIRE_TIME = 2000 // é”çš„è¿‡æœŸæ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
)

type DistributedLock struct {
	Name       string `gorm:&quot;type:varchar(255);primary_key&quot;`
	ExpireTime int64  `gorm:&quot;type:bigint(20)&quot;`
}

func FindLock(name string) (lock *DistributedLock, err error) {
	// æŸ¥è¯¢è®°å½•
	result := GetDB().First(&amp;lock, &quot;name = ?&quot;, name)
	// å¤„ç†æŸ¥è¯¢ç»“æœ
	if result.RowsAffected == 0 {
		return nil, errors.New(&quot;lock not found&quot;)
	} else if result.Error != nil {
		return nil, result.Error
	} else {
		return lock, nil
	}
}

func DeleteLock(name string) (bool, error) {
	db := GetDB()
	tx := db.Begin()

	lock := DistributedLock{
		Name: name,
	}
	if err := tx.Delete(&amp;lock).Error; err != nil {
		tx.Rollback()
		return false, err
	}

	if err := tx.Commit().Error; err != nil {
		tx.Rollback()
		return false, err
	}
	return true, nil
}

func (lock *DistributedLock) AcquireLock(timeout time.Duration) (success bool, err error) {
	startTime := time.Now()                               //å½“å‰æ—¶é—´
	now := startTime.UnixNano() / int64(time.Millisecond) // è·å–å½“å‰æ—¶é—´çš„æ¯«ç§’æ•°
	lock.ExpireTime = now + LOCK_EXPIRE_TIME              // è®¡ç®—é”çš„è¿‡æœŸæ—¶é—´
	//æ£€æŸ¥å¦‚æœå­˜åœ¨é”ï¼Œå…¶æ˜¯å¦è¿‡æœŸ
	existlock, err := FindLock(lock.Name)
	if err != nil {
		fmt.Println(&quot;æŸ¥æ‰¾å­˜åœ¨é”™è¯¯&quot;) //æ³¨ï¼šè¿™é‡Œæ— è®ºæŸ¥æ‰¾æˆåŠŸæˆ–å¤±è´¥ä¸å¦å‡ä¸è¦è¿”å›ï¼Œå› ä¸ºè¿˜æœªå°è¯•è·å–é”å‘¢
	}
	if existlock != nil {
		fmt.Printf(&quot;æŸ¥æ‰¾æˆåŠŸ,å­˜åœ¨è¯¥é”&quot;)
		//å¦‚æœè¿‡æœŸå°±åˆ é™¤
		if now &gt; existlock.ExpireTime {
			fmt.Println(&quot;å·²è¿‡æœŸ&quot;)
			isDelete, err := DeleteLock(lock.Name)
			if err != nil {
				//åˆ é™¤å¤±è´¥
				fmt.Println(&quot;åˆ é™¤å‡ºç°é”™è¯¯&quot;) //æ³¨ï¼šè¿™é‡Œæ— è®ºåˆ é™¤æˆåŠŸæˆ–å¤±è´¥ä¸å¦å‡ä¸è¦è¿”å›ï¼Œå› ä¸ºè¿˜æœªå°è¯•è·å–é”å‘¢
			}
			if isDelete != true {
				fmt.Println(&quot;æœªåˆ é™¤æˆåŠŸ&quot;) //æ³¨ï¼šè¿™é‡Œæ— è®ºåˆ é™¤æˆåŠŸæˆ–å¤±è´¥ä¸å¦å‡ä¸è¦è¿”å›ï¼Œå› ä¸ºè¿˜æœªå°è¯•è·å–é”å‘¢
			}

		} else {
			fmt.Println(&quot;æœªè¿‡æœŸ&quot;)
		}

	}
	for {
		result := GetDB().Create(lock)
		if result.Error == nil || result.RowsAffected != 0 {
			fmt.Println(&quot;AcquireLock Successfully&quot;)
			return true, nil
		}
		if timeout &gt; 0 &amp;&amp; time.Now().Sub(startTime) &gt; timeout {
			return false, nil
		}
		time.Sleep(time.Millisecond * 100)
	}
}

func (lock *DistributedLock) ReleaseLock() (success bool, err error) {
	result := GetDB().Where(&quot;name = ?&quot;, lock.Name).Unscoped().Delete(&amp;DistributedLock{})
	if result.Error != nil || result.RowsAffected == 0 { // å¦‚æœåˆ é™¤å¤±è´¥ï¼Œåˆ™é”ä¸å­˜åœ¨æˆ–å·²è¿‡æœŸ
		fmt.Println(&quot;ReleaseLock UnSuccessfully&quot;)
		return false, nil
	}
	fmt.Println(&quot;ReleaseLock Successfully&quot;)
	return true, nil
}

func main() {
	const LOCK_NAME = &quot;my_lock&quot; // å®šä¹‰é”åç§°
	// è·å–é”
	lock := &amp;DistributedLock{Name: LOCK_NAME, ExpireTime: 0}
	if ok, err := lock.AcquireLock(time.Second * 1); err == nil {
		if ok {
			// è·å–é”æˆåŠŸåçš„æ‰§è¡Œä¸šåŠ¡é€»è¾‘æ“ä½œ
			fmt.Println(&quot;è·å–é”æˆåŠŸï¼Œæˆ‘è¦åšä¸€äº›æ“ä½œäº†&quot;)
			defer lock.ReleaseLock() //é‡Šæ”¾é”
		} else {
			// è·å–é”è¶…æ—¶
			fmt.Println(&quot;timeout: fail to get DistributedLock&quot;)
		}
	} else {
		// è·å–é”å¤±è´¥åçš„æ‰§è¡Œä¸šåŠ¡é€»è¾‘æ“ä½œ
		fmt.Println(&quot;è·å–é”å¤±è´¥&quot;)
	}

}

</code></pre>
<h2 id="1mysqlä¸­åˆ†å¸ƒå¼é”çš„è¡¨ç»“æ„">1.mysqlä¸­åˆ†å¸ƒå¼é”çš„è¡¨ç»“æ„</h2>
<pre><code class="language-mysql">CREATE TABLE `distributed_locks` (
  `name` varchar(255) NOT NULL COMMENT 'é”çš„åç§°',
  `expire_time` BIGINT(20) NOT NULL COMMENT 'è¿‡æœŸæ—¶é—´',
  PRIMARY KEY (`name`)
) COMMENT 'åˆ†å¸ƒå¼é”è¡¨';
</code></pre>
<h2 id="2ä¸mysqlè¿æ¥çš„ä»£ç ">2.ä¸mysqlè¿æ¥çš„ä»£ç </h2>
<p>ä¸mysqlçš„è¿æ¥åŒæ ·é‡‡ç”¨å•ä¾‹æ¨¡å¼</p>
<pre><code class="language-go">var (
	db   *gorm.DB
	once sync.Once
)

func GetDB() *gorm.DB {
	once.Do(func() {
		db = initDB()
	})
	return db
}

func initDB() *gorm.DB {

	var user string = &quot;root&quot;
	var password string = &quot;123456&quot;
	var host string = &quot;localhost&quot;
	var port string = &quot;3306&quot;
	var dbname string = &quot;offermaker&quot;
	var Dsn = fmt.Sprintf(&quot;%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;,
		user,
		password,
		host,
		port,
		filepath.Join(dbname),
	)

	DB, err := gorm.Open(mysql.Open(Dsn), &amp;gorm.Config{})
	if err != nil {
		panic(&quot;failed to connect database, error=&quot; + err.Error())
	}
	fmt.Println(&quot;successfully connect database&quot;)

	return DB
}
</code></pre>
<h2 id="3å®šä¹‰gormç»“æ„ä½“ä¸åŸºç¡€æ“ä½œ">3.å®šä¹‰gormç»“æ„ä½“ä¸åŸºç¡€æ“ä½œ</h2>
<p>gormç»“æ„ä½“ æ˜¯æŒ‡ä¸æ•°æ®åº“è¡¨çš„æ˜ å°„</p>
<p>åŸºç¡€æ“ä½œåœ¨è¿™é‡ŒåŒ…æ‹¬äº† æŸ¥æ‰¾ä¸åˆ é™¤æ•°æ®</p>
<pre><code class="language-go">type DistributedLock struct {
	Name       string `gorm:&quot;type:varchar(255);primary_key&quot;`
	ExpireTime int64  `gorm:&quot;type:bigint(20)&quot;`
}

func FindLock(name string) (lock *DistributedLock, err error) {
	// æŸ¥è¯¢è®°å½•
	result := GetDB().First(&amp;lock, &quot;name = ?&quot;, name)
	// å¤„ç†æŸ¥è¯¢ç»“æœ
	if result.RowsAffected == 0 {
		return nil, errors.New(&quot;lock not found&quot;)
	} else if result.Error != nil {
		return nil, result.Error
	} else {
		return lock, nil
	}
}

func DeleteLock(name string) (bool, error) {
	db := GetDB()
	tx := db.Begin()

	lock := DistributedLock{
		Name: name,
	}
	if err := tx.Delete(&amp;lock).Error; err != nil {
		tx.Rollback()
		return false, err
	}

	if err := tx.Commit().Error; err != nil {
		tx.Rollback()
		return false, err
	}
	return true, nil
}
</code></pre>
<h2 id="4è·å–é”ä¸é‡Šæ”¾é”æ“ä½œ">4.è·å–é”ä¸é‡Šæ”¾é”æ“ä½œ</h2>
<pre><code class="language-go">const (
	LOCK_EXPIRE_TIME = 2000 // é”çš„è¿‡æœŸæ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
)

func (lock *DistributedLock) AcquireLock(timeout time.Duration) (success bool, err error) {
	startTime := time.Now()                               //å½“å‰æ—¶é—´
	now := startTime.UnixNano() / int64(time.Millisecond) // è·å–å½“å‰æ—¶é—´çš„æ¯«ç§’æ•°
	lock.ExpireTime = now + LOCK_EXPIRE_TIME              // è®¡ç®—é”çš„è¿‡æœŸæ—¶é—´
	//æ£€æŸ¥å¦‚æœå­˜åœ¨é”ï¼Œå…¶æ˜¯å¦è¿‡æœŸ
	existlock, err := FindLock(lock.Name)
	if err != nil {
		fmt.Println(&quot;æŸ¥æ‰¾å­˜åœ¨é”™è¯¯&quot;) //æ³¨ï¼šè¿™é‡Œæ— è®ºæŸ¥æ‰¾æˆåŠŸæˆ–å¤±è´¥ä¸å¦å‡ä¸è¦è¿”å›ï¼Œå› ä¸ºè¿˜æœªå°è¯•è·å–é”å‘¢
	}
	if existlock != nil {
		fmt.Printf(&quot;æŸ¥æ‰¾æˆåŠŸ,å­˜åœ¨è¯¥é”&quot;)
		//å¦‚æœè¿‡æœŸå°±åˆ é™¤
		if now &gt; existlock.ExpireTime {
			fmt.Println(&quot;å·²è¿‡æœŸ&quot;)
			isDelete, err := DeleteLock(lock.Name)
			if err != nil {
				//åˆ é™¤å¤±è´¥
				fmt.Println(&quot;åˆ é™¤å‡ºç°é”™è¯¯&quot;) //æ³¨ï¼šè¿™é‡Œæ— è®ºåˆ é™¤æˆåŠŸæˆ–å¤±è´¥ä¸å¦å‡ä¸è¦è¿”å›ï¼Œå› ä¸ºè¿˜æœªå°è¯•è·å–é”å‘¢
			}
			if isDelete != true {
				fmt.Println(&quot;æœªåˆ é™¤æˆåŠŸ&quot;) //æ³¨ï¼šè¿™é‡Œæ— è®ºåˆ é™¤æˆåŠŸæˆ–å¤±è´¥ä¸å¦å‡ä¸è¦è¿”å›ï¼Œå› ä¸ºè¿˜æœªå°è¯•è·å–é”å‘¢
			}

		} else {
			fmt.Println(&quot;æœªè¿‡æœŸ&quot;)
		}

	}
	for {
		result := GetDB().Create(lock)
		if result.Error == nil || result.RowsAffected != 0 {
			fmt.Println(&quot;AcquireLock Successfully&quot;)
			return true, nil
		}
		if timeout &gt; 0 &amp;&amp; time.Now().Sub(startTime) &gt; timeout {
			return false, nil
		}
		time.Sleep(time.Millisecond * 100)
	}
}

func (lock *DistributedLock) ReleaseLock() (success bool, err error) {
	result := GetDB().Where(&quot;name = ?&quot;, lock.Name).Unscoped().Delete(&amp;DistributedLock{})
	if result.Error != nil || result.RowsAffected == 0 { // å¦‚æœåˆ é™¤å¤±è´¥ï¼Œåˆ™é”ä¸å­˜åœ¨æˆ–å·²è¿‡æœŸ
		fmt.Println(&quot;ReleaseLock UnSuccessfully&quot;)
		return false, nil
	}
	fmt.Println(&quot;ReleaseLock Successfully&quot;)
	return true, nil
}

</code></pre>
<h2 id="5ä½¿ç”¨çš„ç¤ºä¾‹ä»£ç ">5.ä½¿ç”¨çš„ç¤ºä¾‹ä»£ç </h2>
<pre><code class="language-go">func main() {
	const LOCK_NAME = &quot;my_lock&quot; // å®šä¹‰é”åç§°
	// è·å–é”
	lock := &amp;DistributedLock{Name: LOCK_NAME, ExpireTime: 0}
	if ok, err := lock.AcquireLock(time.Second * 1); err == nil {
		if ok {
			// è·å–é”æˆåŠŸåçš„æ‰§è¡Œä¸šåŠ¡é€»è¾‘æ“ä½œ
			fmt.Println(&quot;è·å–é”æˆåŠŸï¼Œæˆ‘è¦åšä¸€äº›æ“ä½œäº†&quot;)
			defer lock.ReleaseLock() //é‡Šæ”¾é”
		} else {
			// è·å–é”è¶…æ—¶
			fmt.Println(&quot;timeout: fail to get DistributedLock&quot;)
		}
	} else {
		// è·å–é”å¤±è´¥åçš„æ‰§è¡Œä¸šåŠ¡é€»è¾‘æ“ä½œ
		fmt.Println(&quot;è·å–é”å¤±è´¥&quot;)
	}

}
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E4%B8%80-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5">ä¸€ã€åˆ†å¸ƒå¼é”çš„æ¦‚å¿µ</a>
<ul>
<li><a href="#%E6%A6%82%E5%BF%B5">æ¦‚å¿µ</a></li>
<li><a href="#%E4%B8%BE%E4%BE%8B">ä¸¾ä¾‹</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E5%9F%BA%E4%BA%8Eredis%E7%9A%84%E5%AE%9E%E7%8E%B0">äºŒã€åŸºäºredisçš„å®ç°</a>
<ul>
<li><a href="#0%E5%85%A8%E9%83%A8%E4%BB%A3%E7%A0%81">0.å…¨éƒ¨ä»£ç </a></li>
<li><a href="#1%E4%B8%8Eredis%E8%BF%9E%E6%8E%A5">1.ä¸redisè¿æ¥</a></li>
<li><a href="#2%E8%8E%B7%E5%8F%96%E9%94%81%E6%93%8D%E4%BD%9C%E4%B8%8E%E9%87%8A%E6%94%BE%E9%94%81%E6%93%8D%E4%BD%9C">2.è·å–é”æ“ä½œä¸é‡Šæ”¾é”æ“ä½œ</a></li>
<li><a href="#3%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81">3.ä½¿ç”¨çš„å®ä¾‹ä»£ç </a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E5%9F%BA%E4%BA%8Emysql%E5%AE%9E%E7%8E%B0">ä¸‰ã€åŸºäºmysqlå®ç°</a>
<ul>
<li><a href="#0%E5%85%A8%E9%83%A8%E4%BB%A3%E7%A0%81-2">0.å…¨éƒ¨ä»£ç </a></li>
<li><a href="#1mysql%E4%B8%AD%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E8%A1%A8%E7%BB%93%E6%9E%84">1.mysqlä¸­åˆ†å¸ƒå¼é”çš„è¡¨ç»“æ„</a></li>
<li><a href="#2%E4%B8%8Emysql%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BB%A3%E7%A0%81">2.ä¸mysqlè¿æ¥çš„ä»£ç </a></li>
<li><a href="#3%E5%AE%9A%E4%B9%89gorm%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C">3.å®šä¹‰gormç»“æ„ä½“ä¸åŸºç¡€æ“ä½œ</a></li>
<li><a href="#4%E8%8E%B7%E5%8F%96%E9%94%81%E4%B8%8E%E9%87%8A%E6%94%BE%E9%94%81%E6%93%8D%E4%BD%9C">4.è·å–é”ä¸é‡Šæ”¾é”æ“ä½œ</a></li>
<li><a href="#5%E4%BD%BF%E7%94%A8%E7%9A%84%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">5.ä½¿ç”¨çš„ç¤ºä¾‹ä»£ç </a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '2c8e752d0e362a2a873f',
    clientSecret: '862c97459ff5f1f34a4ff6ce3442f41a00c107e0',
    repo: 'yushen611.github.io',
    owner: 'yushen611',
    admin: ['yushen611'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://yushen611.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
