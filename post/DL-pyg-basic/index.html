<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>pygåŸºç¡€ | YU WENYA&#39;S BLOG</title>
<link rel="shortcut icon" href="https://yushen611.github.io/favicon.ico?v=1694708085062">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://yushen611.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="pygåŸºç¡€ | YU WENYA&#39;S BLOG - Atom Feed" href="https://yushen611.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="
æœ¬æ–‡è®°å½•äº†å¦‚ä½•pygä¸­çš„æ•°æ®ç»“æ„ï¼Œæ•°æ®é›†ï¼Œä»¥åŠç‚¹åˆ†ç±»å¦‚ä½•å†™ä»£ç çš„æµç¨‹
data,dataset,dateloader
torch_geometric.data.Dataï¼šè¡¨ç¤ºå›¾
Dataçš„ä¸¤ç§æ„å»ºæ–¹å¼

dataçš„æ„å»ºæ–¹å¼ä¸€ï¼š[2,edg..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://yushen611.github.io">
  <img class="avatar" src="https://yushen611.github.io/images/avatar.png?v=1694708085062" alt="">
  </a>
  <h1 class="site-title">
    YU WENYA&#39;S BLOG
  </h1>
  <p class="site-description">
    ğŸ‘  æ¬¢è¿æ¥åˆ°ä½™æ–‡æ¶¯çš„åšå®¢ ï¼  <br>
âœï¸  è¿™é‡Œå°†åˆ†äº«æœ‰å…³åŒºå—é“¾/åˆ†å¸ƒå¼ç³»ç»Ÿ/golangå¼€å‘/pythonæœºå™¨å­¦ä¹ ä¸æ•°æ®åˆ†æ/redis/mysql/é¢è¯•å…«è‚¡/leetcodåˆ·é¢˜ ç­‰é¢è¯•ä¸æŠ€æœ¯çŸ¥è¯†ã€‚
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          é¦–é¡µ
        </a>
      
    
      
        <a href="/archives" class="menu">
          å½’æ¡£
        </a>
      
    
      
        <a href="/tags" class="menu">
          æ ‡ç­¾
        </a>
      
    
      
        <a href="/post/about" class="menu">
          å…³äº
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/yushen611" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              pygåŸºç¡€
            </h2>
            <div class="post-info">
              <span>
                2023-08-26
              </span>
              <span>
                34 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <meta name="referrer" content="no-referrer"/>
<p>æœ¬æ–‡è®°å½•äº†å¦‚ä½•pygä¸­çš„æ•°æ®ç»“æ„ï¼Œæ•°æ®é›†ï¼Œä»¥åŠç‚¹åˆ†ç±»å¦‚ä½•å†™ä»£ç çš„æµç¨‹</p>
<h1 id="datadatasetdateloader">data,dataset,dateloader</h1>
<h2 id="torch_geometricdatadataè¡¨ç¤ºå›¾">torch_geometric.data.Dataï¼šè¡¨ç¤ºå›¾</h2>
<h3 id="dataçš„ä¸¤ç§æ„å»ºæ–¹å¼">Dataçš„ä¸¤ç§æ„å»ºæ–¹å¼</h3>
<ul>
<li><strong>dataçš„æ„å»ºæ–¹å¼ä¸€ï¼š[2,edge_nums] + [node_nums,feature_dim]</strong></li>
</ul>
<p>pygä¸­çš„<strong>dataæ˜¯å›¾</strong>ï¼Œå›¾ç”±<strong>æ¯ä¸ªèŠ‚ç‚¹ä»£è¡¨çš„ç‰¹å¾å‘é‡</strong>ï¼Œä»¥åŠå¤§å°ä¸º**[2,edge_num]çš„source to targetçš„è¾¹é›†åˆåˆ—è¡¨**æ„æˆ</p>
<pre><code class="language-python">import torch
from torch_geometric.data import Data

edge_index = torch.tensor([[0, 1, 1, 2],
                           [1, 0, 2, 1]], dtype=torch.long)
x = torch.tensor([[-1], [0], [1]], dtype=torch.float)

data = Data(x=x, edge_index=edge_index)
&gt;&gt;&gt; Data(edge_index=[2, 4], x=[3, 1])
</code></pre>
<p>edge_indexï¼šæŒ‡æ˜äº†å›¾çš„è¾¹ä¿¡æ¯ï¼Œå¤§å°ä¸º[2,edge_nums]</p>
<p>x:æŒ‡æ˜äº†æ¯ä¸ªèŠ‚ç‚¹çš„ç‰¹å¾å‘é‡ï¼Œå¤§å°ä¸º[node_nums,feature_dim]</p>
<figure data-type="image" tabindex="1"><img src="https://pytorch-geometric.readthedocs.io/en/latest/_images/graph.svg" alt="" loading="lazy"></figure>
<p><strong>dataçš„æ„å»ºæ–¹å¼äºŒï¼š[edge_nums,2].t().contiguous() + [node_nums,feature_dim]</strong></p>
<pre><code class="language-python">import torch
from torch_geometric.data import Data

edge_index = torch.tensor([[0, 1],
                           [1, 0],
                           [1, 2],
                           [2, 1]], dtype=torch.long)
x = torch.tensor([[-1], [0], [1]], dtype=torch.float)

data = Data(x=x, edge_index=edge_index.t().contiguous())
&gt;&gt;&gt; Data(edge_index=[2, 4], x=[3, 1])
</code></pre>
<h3 id="dataçš„å±æ€§">Dataçš„å±æ€§</h3>
<ul>
<li><code>data.x</code>: èŠ‚ç‚¹nodeçš„ç‰¹æ€§å‘é‡çŸ©é˜µ ï¼Œå¤§å°ä¸º<code>[num_nodes, num_node_features]</code></li>
<li><code>data.edge_index</code>: source to target è¾¹edgeçŸ©é˜µ <code>[2, num_edges]``torch.long</code></li>
<li><code>data.edge_attr</code>: è¾¹Edgeçš„ç‰¹å¾å‘é‡çŸ©é˜µ ï¼Œå¤§å°ä¸º<code>[num_edges, num_edge_features]</code></li>
<li><code>data.y</code>: å¯¹äºnode-level targetsï¼Œå…¶å¤§å°ä¸ºã€‚å¯¹äº graph-level targets ,å…¶å¤§å°ä¸º <code>[num_nodes, *]``[1, *]</code></li>
</ul>
<blockquote>
<ol>
<li><strong>Node-level targets (èŠ‚ç‚¹çº§åˆ«ç›®æ ‡):</strong> è¿™é‡Œæåˆ°çš„ <code>data.y</code> å¯ä»¥æ˜¯èŠ‚ç‚¹çº§åˆ«çš„ç›®æ ‡ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„ç›®æ ‡å€¼ã€‚ç›®æ ‡å€¼å¯ä»¥å…·æœ‰ä»»æ„å½¢çŠ¶ï¼Œè¿™æ„å‘³ç€å®ƒå¯ä»¥æ˜¯ä¸€ä¸ªæ ‡é‡ï¼ˆä¾‹å¦‚èŠ‚ç‚¹çš„ç±»åˆ«æ ‡ç­¾ï¼‰ï¼Œä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ªå‘é‡æˆ–çŸ©é˜µï¼ˆä¾‹å¦‚èŠ‚ç‚¹çš„å±æ€§å‘é‡ï¼‰ã€‚<code>data.y</code> çš„å½¢çŠ¶å¯èƒ½æ˜¯ <code>[num_nodes, *]</code>ï¼Œå…¶ä¸­ <code>num_nodes</code> æ˜¯å›¾ä¸­èŠ‚ç‚¹çš„æ•°é‡ï¼Œ<code>*</code> è¡¨ç¤ºä»»æ„ç»´åº¦ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæ¯ä¸ªèŠ‚ç‚¹çš„ç›®æ ‡æ˜¯ä¸€ä¸ªé•¿åº¦ä¸º 3 çš„å‘é‡ï¼Œé‚£ä¹ˆ <code>data.y</code> çš„å½¢çŠ¶å¯èƒ½æ˜¯ <code>[num_nodes, 3]</code>ã€‚</li>
<li><strong>Graph-level targets (å›¾çº§åˆ«ç›®æ ‡):</strong> å¦ä¸€ç§æƒ…å†µæ˜¯ï¼Œ<code>data.y</code> å¯ä»¥æ˜¯å›¾çº§åˆ«çš„ç›®æ ‡ã€‚è¿™æ„å‘³ç€æ•´ä¸ªå›¾æœ‰ä¸€ä¸ªå¯¹åº”çš„ç›®æ ‡å€¼ã€‚åŒæ ·ï¼Œç›®æ ‡å€¼å¯ä»¥å…·æœ‰ä»»æ„å½¢çŠ¶ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå½¢çŠ¶å¯èƒ½æ˜¯ <code>[1, *]</code>ï¼Œå…¶ä¸­ <code>*</code> è¡¨ç¤ºä»»æ„ç»´åº¦ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä½ çš„å›¾ä»£è¡¨ä¸€ä¸ªæ–‡æ¡£ï¼Œç›®æ ‡å¯ä»¥æ˜¯æ–‡æ¡£çš„ä¸»é¢˜æˆ–æƒ…æ„Ÿæ ‡ç­¾ï¼Œå½¢çŠ¶å¯èƒ½æ˜¯ <code>[1, num_topics]</code>ï¼Œå…¶ä¸­ <code>num_topics</code> æ˜¯ä¸»é¢˜çš„æ•°é‡ã€‚</li>
</ol>
<p>æ€»ä¹‹ï¼Œ<code>data.y</code> æ˜¯å›¾æ•°æ®å¯¹è±¡ä¸­ç”¨äºå­˜å‚¨ç›®æ ‡ä¿¡æ¯çš„å±æ€§ã€‚å®ƒå¯ä»¥è¡¨ç¤ºèŠ‚ç‚¹çº§åˆ«æˆ–å›¾çº§åˆ«çš„ç›®æ ‡ï¼Œå…·ä½“å½¢çŠ¶å–å†³äºä»»åŠ¡çš„è¦æ±‚ã€‚åœ¨è®­ç»ƒå›¾ç¥ç»ç½‘ç»œæˆ–å…¶ä»–å›¾æ•°æ®ç›¸å…³çš„æ¨¡å‹æ—¶ï¼Œä½ å¯ä»¥ä½¿ç”¨ <code>data.y</code> æ¥æŒ‡å¯¼æ¨¡å‹çš„è®­ç»ƒå’Œä¼˜åŒ–è¿‡ç¨‹ã€‚</p>
</blockquote>
<ul>
<li><code>data.pos</code>: å­˜å‚¨èŠ‚ç‚¹çš„åæ ‡ï¼Œå½¢çŠ¶æ˜¯<code>[num_nodes, num_dimensions]</code></li>
</ul>
<blockquote>
<p><code>data.pos</code> æ˜¯å›¾æ•°æ®å¯¹è±¡ä¸­çš„ä¸€ä¸ªå±æ€§ï¼Œç”¨äºå­˜å‚¨èŠ‚ç‚¹åœ¨ç©ºé—´ä¸­çš„ä½ç½®ä¿¡æ¯ï¼Œå½¢çŠ¶ä¸º <code>[num_nodes, num_dimensions]</code>ã€‚</p>
<ul>
<li><code>data.pos</code>ï¼šè¡¨ç¤ºå›¾æ•°æ®å¯¹è±¡ä¸­çš„èŠ‚ç‚¹ä½ç½®çŸ©é˜µã€‚</li>
<li><code>num_nodes</code>ï¼šå›¾ä¸­èŠ‚ç‚¹çš„æ•°é‡ã€‚</li>
<li><code>num_dimensions</code>ï¼šè¡¨ç¤ºæ¯ä¸ªèŠ‚ç‚¹çš„ä½ç½®åœ¨å¤šå°‘ç»´åº¦ä¸Šè¿›è¡Œæè¿°ï¼Œé€šå¸¸ä¸º 2 æˆ– 3ã€‚</li>
</ul>
<p>è¿™æ„å‘³ç€å¯¹äºä¸€ä¸ªåŒ…å«å¤šä¸ªèŠ‚ç‚¹çš„å›¾ï¼Œ<code>data.pos</code> æ˜¯ä¸€ä¸ªçŸ©é˜µï¼Œå…¶å½¢çŠ¶ä¸º <code>[num_nodes, num_dimensions]</code>ã€‚åœ¨äºŒç»´æƒ…å†µä¸‹ï¼Œæ¯ä¸€è¡Œè¡¨ç¤ºä¸€ä¸ªèŠ‚ç‚¹çš„ä½ç½®ï¼Œè€Œåˆ—åˆ™å¯¹åº”äºè¯¥ä½ç½®çš„ x å’Œ y åæ ‡ã€‚åœ¨ä¸‰ç»´æƒ…å†µä¸‹ï¼Œæ¯ä¸€è¡Œè¡¨ç¤ºä¸€ä¸ªèŠ‚ç‚¹çš„ä½ç½®ï¼Œè€Œåˆ—åˆ™å¯¹åº”äº xã€y å’Œ z åæ ‡ã€‚</p>
<p>é€šå¸¸æƒ…å†µä¸‹ï¼Œ<code>data.pos</code> çš„ä¿¡æ¯ç”¨äºè¡¨ç¤ºèŠ‚ç‚¹åœ¨æŸä¸ªç©ºé—´ä¸­çš„ä½ç½®ï¼Œä¾‹å¦‚åœ¨äºŒç»´ç©ºé—´ä¸­çš„åæ ‡æˆ–ä¸‰ç»´ç©ºé—´ä¸­çš„åæ ‡ã€‚è¿™åœ¨è®¸å¤šå›¾æ•°æ®ä»»åŠ¡ä¸­éƒ½æ˜¯æœ‰ç”¨çš„ï¼Œæ¯”å¦‚å¯è§†åŒ–å›¾ã€ç©ºé—´åˆ†æç­‰ã€‚</p>
</blockquote>
<ul>
<li><code>data.face</code> å±æ€§æ¥å­˜å‚¨ä¸‰ç»´ç½‘æ ¼ä¸­ä¸‰è§’å½¢çš„è¿æ¥ä¿¡æ¯</li>
</ul>
<blockquote>
<p><code>data.face</code> å±æ€§ç”¨äºå­˜å‚¨ä¸‰ç»´ç½‘æ ¼ä¸­ä¸‰è§’å½¢çš„è¿æ¥ä¿¡æ¯ã€‚è¯¥å¼ é‡çš„å½¢çŠ¶ä¸º <code>[3, num_faces]</code>ï¼Œå…¶ä¸­ <code>num_faces</code> è¡¨ç¤ºç½‘æ ¼ä¸­ä¸‰è§’å½¢çš„æ•°é‡ã€‚å¼ é‡ä¸­çš„æ¯ä¸€åˆ—å¯¹åº”ä¸€ä¸ªä¸‰è§’å½¢çš„é¡¶ç‚¹ï¼Œè€Œå½¢çŠ¶ä¸­çš„ <code>3</code> è¡¨ç¤ºæ¯ä¸ªä¸‰è§’å½¢ç”±ä¸‰ä¸ªé¡¶ç‚¹ç´¢å¼•å®šä¹‰ã€‚</p>
</blockquote>
<ul>
<li><code>data</code> å¯¹è±¡å¯ä»¥å…·æœ‰ <code>train_mask</code>ã€<code>val_mask</code> å’Œ <code>test_mask</code> ç­‰å±æ€§</li>
</ul>
<blockquote>
<p>è¿™ä¸‰ä¸ªå±æ€§ç”¨äºæŒ‡ç¤ºå“ªäº›èŠ‚ç‚¹è¢«ç”¨äºè®­ç»ƒã€éªŒè¯å’Œæµ‹è¯•ã€‚è¿™äº›å±æ€§é€šå¸¸åœ¨å›¾ç¥ç»ç½‘ç»œæ¨¡å‹çš„è®­ç»ƒã€éªŒè¯å’Œæµ‹è¯•è¿‡ç¨‹ä¸­ç”¨äºèŠ‚ç‚¹çš„åˆ’åˆ†å’Œé€‰æ‹©ã€‚è¿™äº›å¸ƒå°”æ©ç å±æ€§å¯ä»¥ç”¨äºæ ¹æ®ä½ çš„è®­ç»ƒã€éªŒè¯å’Œæµ‹è¯•éœ€æ±‚ï¼Œå¯¹å›¾æ•°æ®ä¸­çš„èŠ‚ç‚¹è¿›è¡Œåˆ’åˆ†ã€‚åœ¨æ¨¡å‹è®­ç»ƒã€éªŒè¯å’Œæµ‹è¯•è¿‡ç¨‹ä¸­ï¼Œä½ å¯ä»¥ä½¿ç”¨è¿™äº›å±æ€§æ¥é€‰æ‹©é€‚å½“çš„èŠ‚ç‚¹ï¼Œä»¥ä¾¿è¿›è¡Œç›¸åº”çš„æ“ä½œå’Œè®¡ç®—ã€‚è¿™åœ¨å›¾ç¥ç»ç½‘ç»œçš„å®éªŒå’Œè¯„ä¼°ä¸­éå¸¸æœ‰ç”¨</p>
<p>è¿™äº›å±æ€§æ˜¯å¸ƒå°”æ©ç ï¼ˆBoolean maskï¼‰æ•°ç»„ï¼Œå…¶é•¿åº¦ä¸å›¾ä¸­çš„èŠ‚ç‚¹æ•°é‡ç›¸åŒã€‚æ¯ä¸ªå…ƒç´ çš„å€¼æŒ‡ç¤ºå¯¹åº”èŠ‚ç‚¹æ˜¯å¦åœ¨å¯¹åº”çš„é›†åˆä¸­ï¼ˆä¾‹å¦‚ï¼Œè®­ç»ƒé›†ã€éªŒè¯é›†ã€æµ‹è¯•é›†ï¼‰ã€‚</p>
<ul>
<li><strong><code>train_mask</code>ï¼š</strong> ç”¨äºæŒ‡ç¤ºå“ªäº›èŠ‚ç‚¹è¢«ç”¨äºæ¨¡å‹çš„è®­ç»ƒã€‚å¯¹äºè®­ç»ƒé›†ä¸­çš„èŠ‚ç‚¹ï¼Œç›¸åº”ä½ç½®çš„å…ƒç´ å€¼ä¸º <code>True</code>ï¼Œå¦åˆ™ä¸º <code>False</code>ã€‚</li>
<li><strong><code>val_mask</code>ï¼š</strong> ç”¨äºæŒ‡ç¤ºå“ªäº›èŠ‚ç‚¹è¢«ç”¨äºæ¨¡å‹çš„éªŒè¯ã€‚å¯¹äºéªŒè¯é›†ä¸­çš„èŠ‚ç‚¹ï¼Œç›¸åº”ä½ç½®çš„å…ƒç´ å€¼ä¸º <code>True</code>ï¼Œå¦åˆ™ä¸º <code>False</code>ã€‚</li>
<li><strong><code>test_mask</code>ï¼š</strong> ç”¨äºæŒ‡ç¤ºå“ªäº›èŠ‚ç‚¹è¢«ç”¨äºæ¨¡å‹çš„æµ‹è¯•ã€‚å¯¹äºæµ‹è¯•é›†ä¸­çš„èŠ‚ç‚¹ï¼Œç›¸åº”ä½ç½®çš„å…ƒç´ å€¼ä¸º <code>True</code>ï¼Œå¦åˆ™ä¸º <code>False</code>ã€‚</li>
</ul>
</blockquote>
<pre><code class="language-python">data = ...  # åˆ›å»ºä½ çš„ Data å¯¹è±¡

# æŒ‡å®šå“ªäº›èŠ‚ç‚¹ç”¨äºè®­ç»ƒã€éªŒè¯å’Œæµ‹è¯•
data.train_mask = torch.tensor([True, True, False, False, True, False, ...])  # è®­ç»ƒé›†
data.val_mask = torch.tensor([False, False, True, True, False, False, ...])   # éªŒè¯é›†
data.test_mask = torch.tensor([False, False, False, False, False, True, ...]) # æµ‹è¯•é›†
</code></pre>
<p>æŸ¥çœ‹è¢«æ ‡è®°ä¸ºè®­ç»ƒã€éªŒè¯ã€æµ‹è¯•çš„èŠ‚ç‚¹æ•°é‡</p>
<pre><code class="language-python">data.train_mask.sum().item() # è®¡ç®—è®­ç»ƒé›†ä¸­è¢«æ ‡è®°ä¸º `True` çš„èŠ‚ç‚¹æ•°é‡
&gt;&gt;&gt; 140

data.val_mask.sum().item() # è®¡ç®—éªŒè¯é›†ä¸­è¢«æ ‡è®°ä¸º `True` çš„èŠ‚ç‚¹æ•°é‡
&gt;&gt;&gt; 500

data.test_mask.sum().item() # è®¡ç®—æµ‹è¯•é›†ä¸­è¢«æ ‡è®°ä¸º `True` çš„èŠ‚ç‚¹æ•°é‡
&gt;&gt;&gt; 1000
</code></pre>
<p>è®­ç»ƒï¼Œæµ‹è¯•ï¼ŒéªŒè¯æ—¶ï¼Œæ€ä¹ˆä½¿ç”¨<code>train_mask</code>,<code>val_mask</code>,<code>test_mask</code></p>
<p>æ¨¡å‹å‡è®¾å®šä¹‰å¦‚ä¸‹</p>
<pre><code class="language-python">import torch
import torch.nn.functional as F
from torch_geometric.data import DataLoader
from torch_geometric.nn import GCNConv

# å‡è®¾ data æ˜¯å›¾æ•°æ®å¯¹è±¡ï¼ŒåŒ…å« xï¼ˆèŠ‚ç‚¹ç‰¹å¾ï¼‰å’Œ train_mask,test_mask ,val_mask 
data = ...

# åˆ›å»ºä¸€ä¸ªå›¾ç¥ç»ç½‘ç»œæ¨¡å‹
class GCN(torch.nn.Module):
    def __init__(self):
        super(GCN, self).__init__()
        self.conv1 = GCNConv(in_channels=data.num_features, out_channels=16)
        self.conv2 = GCNConv(in_channels=16, out_channels=data.num_classes)

    def forward(self, x, edge_index):
        x = self.conv1(x, edge_index)
        x = F.relu(x)
        x = F.dropout(x, training=self.training)
        x = self.conv2(x, edge_index)
        return F.log_softmax(x, dim=1)

model = GCN()
</code></pre>
<p><code>train_mask</code>ç”¨æ³•</p>
<pre><code class="language-python">model = GCN()
# è®¾ç½®æ¨¡å‹ä¸ºè®­ç»ƒæ¨¡å¼
model.train()

# å°†æ•°æ®é€å…¥æ¨¡å‹è¿›è¡Œè®­ç»ƒ
optimizer = torch.optim.Adam(model.parameters(), lr=0.01)
optimizer.zero_grad()

out = model(data.x, data.edge_index)

# ä½¿ç”¨ train_mask é€‰æ‹©è®­ç»ƒèŠ‚ç‚¹
loss = F.nll_loss(out[data.train_mask], data.y[data.train_mask])
loss.backward()
optimizer.step()
</code></pre>
<p><code>test_mask</code>ç”¨æ³•</p>
<pre><code class="language-python">model = GCN()

# è®¾ç½®æ¨¡å‹ä¸ºè¯„ä¼°æ¨¡å¼ï¼ˆä¸ä½¿ç”¨ dropoutï¼‰
model.eval()

# å°†æ•°æ®é€å…¥æ¨¡å‹è¿›è¡ŒéªŒè¯
out = model(data.x, data.edge_index)

# ä½¿ç”¨ val_mask é€‰æ‹©éªŒè¯èŠ‚ç‚¹
loss = F.nll_loss(out[data.val_mask], data.y[data.val_mask])

# è¿›è¡Œåç»­çš„æ€§èƒ½è¯„ä¼°ã€è¶…å‚æ•°è°ƒæ•´ç­‰æ“ä½œ
</code></pre>
<p><code>val_mask</code>ç”¨æ³•</p>
<pre><code class="language-python">model = GCN()

# è®¾ç½®æ¨¡å‹ä¸ºè¯„ä¼°æ¨¡å¼ï¼ˆä¸ä½¿ç”¨ dropoutï¼‰
model.eval()

# å°†æ•°æ®é€å…¥æ¨¡å‹è¿›è¡ŒéªŒè¯
out = model(data.x, data.edge_index)

# ä½¿ç”¨ val_mask é€‰æ‹©éªŒè¯èŠ‚ç‚¹
loss = F.nll_loss(out[data.val_mask], data.y[data.val_mask])

# è¿›è¡Œåç»­çš„æ€§èƒ½è¯„ä¼°ã€è¶…å‚æ•°è°ƒæ•´ç­‰æ“ä½œ
</code></pre>
<p><code>model.train()</code> å’Œ <code>model.eval()</code> æ–¹æ³•æ˜¯pytorchä¸­çš„æ ‡å‡†æ–¹æ³•</p>
<blockquote>
<p>åœ¨ PyTorch Geometric ä¸­ï¼Œé€šè¿‡è°ƒç”¨ <code>model.train()</code> å’Œ <code>model.eval()</code> æ–¹æ³•ï¼Œä½ å¯ä»¥å°†æ¨¡å‹è®¾ç½®ä¸ºè®­ç»ƒæ¨¡å¼å’Œè¯„ä¼°æ¨¡å¼ï¼Œåˆ†åˆ«ç”¨äºè®­ç»ƒå’Œæµ‹è¯•é˜¶æ®µã€‚<strong>è¿™äº›æ–¹æ³•æ˜¯ PyTorch ä¸­çš„æ ‡å‡†æ–¹æ³•</strong>ï¼Œç”¨äºå¯ç”¨æˆ–ç¦ç”¨æŸäº›æ¨¡å‹å±‚ï¼ˆå¦‚ dropout æˆ– batch normalizationï¼‰ä¸­çš„ç‰¹å®šè¡Œä¸ºã€‚</p>
</blockquote>
<h3 id="dataçš„å…¶ä»–ç”¨æ³•">Dataçš„å…¶ä»–ç”¨æ³•</h3>
<p><code>data.to(device)</code>æŠŠdataæ”¾åˆ°GPUä¸Šè·‘</p>
<pre><code class="language-python">device = torch.device('cuda')
data = data.to(device)
</code></pre>
<p><code>data.validate(raise_on_error=True) </code>æ£€æŸ¥å›¾çš„åˆæ³•æ€§</p>
<blockquote>
<p>åœ¨ PyTorch Geometricï¼ˆPyGï¼‰åº“ä¸­ï¼Œ<code>Data</code> å¯¹è±¡å…·æœ‰ä¸€ä¸ªåä¸º <code>validate</code> çš„æ–¹æ³•ï¼Œç”¨äºéªŒè¯æ•°æ®å¯¹è±¡çš„ä¸€è‡´æ€§å’Œæœ‰æ•ˆæ€§ã€‚è¿™ä¸ªæ–¹æ³•å¯ä»¥å¸®åŠ©ä½ ç¡®ä¿ä½ çš„æ•°æ®å¯¹è±¡çš„å„ä¸ªå±æ€§è®¾ç½®æ­£ç¡®ï¼Œä»¥ä¾¿åœ¨ä½¿ç”¨å›¾ç¥ç»ç½‘ç»œå’Œå…¶ä»–æ¨¡å‹æ—¶ä¸ä¼šå‡ºç°é”™è¯¯ã€‚</p>
<p>å…·ä½“æ¥è¯´ï¼Œå½“ä½ è°ƒç”¨ <code>data.validate()</code> æ—¶ï¼ŒPyG å°†æ£€æŸ¥ <code>Data</code> å¯¹è±¡çš„å„ä¸ªå±æ€§æ˜¯å¦æ»¡è¶³ä¸€äº›å¸¸è§çš„åˆæ³•æ€§è¦æ±‚ã€‚å¦‚æœä»»ä½•å±æ€§ä¸ç¬¦åˆé¢„æœŸï¼Œæ ¹æ® <code>raise_on_error</code> å‚æ•°çš„å€¼ï¼Œå®ƒä¼šæŠ›å‡ºä¸€ä¸ªå¼‚å¸¸ï¼ˆå¦‚æœä¸º <code>True</code>ï¼‰æˆ–è€…ä»…è¾“å‡ºä¸€æ¡è­¦å‘Šæ¶ˆæ¯ï¼ˆå¦‚æœä¸º <code>False</code>ï¼Œè¿™æ˜¯é»˜è®¤å€¼ï¼‰ã€‚</p>
</blockquote>
<pre><code class="language-python">data = ...  # åˆ›å»ºä½ çš„ Data å¯¹è±¡
data.validate(raise_on_error=True)  # éªŒè¯å¹¶åœ¨é”™è¯¯æ—¶å¼•å‘å¼‚å¸¸
</code></pre>
<p>å…¶ä»–ç”¨æ³•</p>
<pre><code class="language-python">print(data.keys())
&gt;&gt;&gt; ['x', 'edge_index']

print(data['x'])
&gt;&gt;&gt; tensor([[-1.0],
            [0.0],
            [1.0]])

for key, item in data:
    print(f'{key} found in data')
&gt;&gt;&gt; x found in data
&gt;&gt;&gt; edge_index found in data

'edge_attr' in data
&gt;&gt;&gt; False

data.num_nodes # èŠ‚ç‚¹æ•°é‡
&gt;&gt;&gt; 3

data.num_edges # è¾¹æ•°é‡
&gt;&gt;&gt; 4

data.num_node_features #èŠ‚ç‚¹çš„ç‰¹å¾ç»´åº¦
&gt;&gt;&gt; 1

data.has_isolated_nodes() #æ£€æŸ¥å›¾æ•°æ®å¯¹è±¡ä¸­æ˜¯å¦å­˜åœ¨å­¤ç«‹èŠ‚ç‚¹ï¼ˆisolated nodesï¼‰
&gt;&gt;&gt; False

data.has_self_loops() #æ£€æŸ¥å›¾æ•°æ®å¯¹è±¡æ˜¯å¦åŒ…å«è‡ªç¯ï¼ˆself-loopsï¼‰
&gt;&gt;&gt; False

data.is_directed() # æ£€æŸ¥å›¾æ˜¯å¦ä¸ºæœ‰å‘å›¾
&gt;&gt;&gt; False
data.is_undirected()# æ£€æŸ¥å›¾æ˜¯å¦ä¸ºæ— å‘å›¾
&gt;&gt;&gt; True

</code></pre>
<h2 id="torch_geometricdatasets">torch_geometric.datasets</h2>
<h3 id="ä½¿ç”¨è‡ªå¸¦æ•°æ®é›†">ä½¿ç”¨è‡ªå¸¦æ•°æ®é›†</h3>
<p>pygè‡ªå¸¦çš„æ•°æ®é›†æœ‰äº”å¤§ç±»æ•°æ®é›†:Homogeneous Datasets, Heterogeneous Datasets ,Synthetic Datasets ,Graph Generators ,Motif Generators</p>
<blockquote>
<ol>
<li><strong>Homogeneous Datasets (åŒè´¨æ•°æ®é›†):</strong> åŒè´¨æ•°æ®é›†æ˜¯æŒ‡å…¶ä¸­æ‰€æœ‰èŠ‚ç‚¹å’Œè¾¹éƒ½å±äºç›¸åŒçš„ç±»å‹ã€‚ä¾‹å¦‚ï¼Œåœ¨ç¤¾äº¤ç½‘ç»œä¸­ï¼Œå¦‚æœæ‰€æœ‰çš„èŠ‚ç‚¹éƒ½è¡¨ç¤ºç”¨æˆ·ï¼Œè€Œæ‰€æœ‰çš„è¾¹è¡¨ç¤ºå…³æ³¨å…³ç³»ï¼Œé‚£ä¹ˆè¿™å°±æ˜¯ä¸€ä¸ªåŒè´¨æ•°æ®é›†ã€‚è¿™æ„å‘³ç€æ•°æ®é›†ä¸­çš„èŠ‚ç‚¹å’Œè¾¹ä¹‹é—´æ²¡æœ‰æ˜æ˜¾çš„ç±»å‹å·®å¼‚ã€‚</li>
<li><strong>Heterogeneous Datasets (å¼‚è´¨æ•°æ®é›†):</strong> å¼‚è´¨æ•°æ®é›†æ˜¯æŒ‡å…¶ä¸­èŠ‚ç‚¹å’Œè¾¹å¯ä»¥å±äºä¸åŒçš„ç±»å‹ã€‚ä¾‹å¦‚ï¼Œåœ¨ä¸€ä¸ªå­¦æœ¯ç½‘ç»œä¸­ï¼ŒèŠ‚ç‚¹å¯èƒ½è¡¨ç¤ºä½œè€…ã€è®ºæ–‡å’Œä¼šè®®ï¼Œè€Œè¾¹å¯èƒ½è¡¨ç¤ºä½œè€…-è®ºæ–‡å’Œè®ºæ–‡-ä¼šè®®çš„å…³ç³»ã€‚è¿™ç§æ•°æ®é›†åæ˜ äº†å›¾ä¸­çš„å®ä½“ä¹‹é—´çš„ä¸åŒç±»å‹å…³è”ã€‚</li>
<li><strong>Synthetic Datasets (åˆæˆæ•°æ®é›†):</strong> åˆæˆæ•°æ®é›†æ˜¯é€šè¿‡æ¨¡æ‹Ÿæˆ–äººå·¥åˆ›å»ºçš„æ•°æ®é›†ï¼Œç”¨äºæµ‹è¯•å’Œè¯„ä¼°ç®—æ³•ã€‚è¿™äº›æ•°æ®é›†ä¸æ¥è‡ªçœŸå®ä¸–ç•Œï¼Œè€Œæ˜¯æ ¹æ®ç‰¹å®šè§„åˆ™æˆ–æ¨¡å‹ç”Ÿæˆçš„ã€‚åˆæˆæ•°æ®é›†å¯ç”¨äºéªŒè¯ç®—æ³•çš„æ€§èƒ½ã€ç¨³å®šæ€§å’Œé€‚ç”¨æ€§ã€‚</li>
<li><strong>Graph Generators (å›¾ç”Ÿæˆå™¨):</strong> å›¾ç”Ÿæˆå™¨æ˜¯ç”¨äºç”Ÿæˆå›¾æ•°æ®çš„ç®—æ³•æˆ–å·¥å…·ã€‚è¿™äº›ç”Ÿæˆå™¨å¯ä»¥åˆ›å»ºä¸åŒç±»å‹çš„å›¾ï¼Œå¦‚éšæœºå›¾ã€å°ä¸–ç•Œå›¾ã€æ— æ ‡åº¦ç½‘ç»œç­‰ã€‚å¸¸è§çš„å›¾ç”Ÿæˆå™¨åŒ…æ‹¬ ErdÅ‘s-RÃ©nyi æ¨¡å‹ã€Watts-Strogatz æ¨¡å‹ã€BarabÃ¡si-Albert æ¨¡å‹ç­‰ã€‚</li>
<li><strong>Motif Generators (æ¨¡ä½“ç”Ÿæˆå™¨):</strong> æ¨¡ä½“æ˜¯å›¾ä¸­çš„å°å‹å­å›¾æ¨¡å¼ï¼Œå…·æœ‰ç‰¹å®šçš„æ‹“æ‰‘ç»“æ„å’ŒåŠŸèƒ½ã€‚æ¨¡ä½“ç”Ÿæˆå™¨æ˜¯ç”¨äºç”Ÿæˆè¿™äº›å°å‹å­å›¾çš„å·¥å…·ã€‚æ¨¡ä½“åœ¨å›¾åˆ†æä¸­å¾ˆæœ‰ç”¨ï¼Œå› ä¸ºå®ƒä»¬å¯ä»¥å¸®åŠ©æ­ç¤ºå›¾ä¸­çš„é‡è¦æ¨¡å¼å’Œç»“æ„ã€‚</li>
</ol>
<p>ç»¼ä¸Šæ‰€è¿°ï¼Œè¿™äº›æœ¯è¯­æ¶µç›–äº†ä¸åŒç±»å‹çš„å›¾æ•°æ®é›†å’Œç”Ÿæˆæ–¹æ³•ã€‚åŒè´¨å’Œå¼‚è´¨æ•°æ®é›†ä¹‹é—´çš„åŒºåˆ«åœ¨äºå®ä½“ä¹‹é—´çš„ç±»å‹å…³ç³»ã€‚åˆæˆæ•°æ®é›†æ˜¯äººå·¥åˆ›å»ºçš„ï¼Œç”¨äºæµ‹è¯•ç®—æ³•ã€‚å›¾ç”Ÿæˆå™¨å¯ä»¥è‡ªåŠ¨ç”Ÿæˆå›¾ï¼Œè€Œæ¨¡ä½“ç”Ÿæˆå™¨åˆ™ç”¨äºç”Ÿæˆå›¾ä¸­çš„æ¨¡ä½“ï¼Œä»¥æ­ç¤ºå›¾çš„å±€éƒ¨ç»“æ„ã€‚</p>
</blockquote>
<p>An initialization of a dataset <strong>will automatically download its raw files and process them to the previously described <a href="https://pytorch-geometric.readthedocs.io/en/latest/generated/torch_geometric.data.Data.html#torch_geometric.data.Data"><code>Data</code></a> format</strong>. <em>E.g.</em>, to load the ENZYMES dataset (consisting of 600 graphs within 6 classes), type:</p>
<pre><code class="language-python">from torch_geometric.datasets import TUDataset

dataset = TUDataset(root='/tmp/ENZYMES', name='ENZYMES')
&gt;&gt;&gt; ENZYMES(600)

len(dataset) # datasetçš„é•¿åº¦æ˜¯æŒ‡å›¾çš„æ•°é‡
&gt;&gt;&gt; 600

dataset.num_classes # å›¾çš„ç±»æ•°
&gt;&gt;&gt; 6

dataset.num_node_features # å›¾çš„èŠ‚ç‚¹ç‰¹å¾æ•°
&gt;&gt;&gt; 3
</code></pre>
<p>å¦ä¸€ä¸ªä¾‹å­</p>
<pre><code class="language-python">from torch_geometric.datasets import Planetoid
dataset = Planetoid(root=&quot;tutorial1&quot;,name= &quot;Cora&quot;)
data = dataset[0]

print(dataset)
&gt;&gt;&gt; Cora()
print(&quot;number of graphs:\t\t&quot;,len(dataset))
&gt;&gt;&gt; number of graphs:		 1
print(&quot;number of classes:\t\t&quot;,dataset.num_classes)
&gt;&gt;&gt; number of classes:		 7
print(&quot;number of node features:\t&quot;,dataset.num_node_features)
&gt;&gt;&gt; number of node features:	 1433
print(&quot;number of edge features:\t&quot;,dataset.num_edge_features)
&gt;&gt;&gt; number of edge features:	 0
</code></pre>
<h3 id="åˆ›å»ºä¸€ä¸ªè‡ªå·±çš„æ•°æ®é›†">åˆ›å»ºä¸€ä¸ªè‡ªå·±çš„æ•°æ®é›†</h3>
<p>åœ¨å®˜æ–¹æ–‡æ¡£ä¸­æœ‰é“¾æ¥ï¼ˆç‚¹è¿›datasetï¼Œç‚¹nextåˆ°ä¸‹ä¸€é¡µå°±èƒ½çœ‹åˆ°ï¼‰ï¼Œå¯ä»¥çœ‹åˆ°æ¯ä¸ªæ•°æ®é›†çš„å­ç±»ï¼Œè¦ä¹ˆç»§æ‰¿äº<code>InMemoryDataset</code>ï¼Œè¦ä¹ˆç»§æ‰¿äº<code>torch_geometric.data.Dataset</code>ã€‚åè€…éœ€è¦æ¯”å‰è€…é¢å¤–å®ç°lenå’Œgetå‡½æ•°ã€‚</p>
<ul>
<li>InMemoryDatasetï¼šä½¿ç”¨è¿™ä¸ª<code>Dataset</code>ä¼šä¸€æ¬¡æ€§æŠŠæ•°æ®å…¨éƒ¨åŠ è½½åˆ°å†…å­˜ä¸­ã€‚</li>
<li>Dataset: ä½¿ç”¨è¿™ä¸ª<code>Dataset</code>æ¯æ¬¡åŠ è½½ä¸€ä¸ªæ•°æ®åˆ°å†…å­˜ä¸­ï¼Œæ¯”è¾ƒå¸¸ç”¨ã€‚</li>
</ul>
<ol>
<li><strong>ImMemoryçš„å®ç°</strong></li>
</ol>
<pre><code class="language-python">import torch
from torch_geometric.data import InMemoryDataset


class MyOwnDataset(InMemoryDataset):
    def __init__(self, root, transform=None, pre_transform=None):
        super(MyOwnDataset, self).__init__(root, transform, pre_transform)
        # åœ¨æ­¤åˆå§‹åŒ–ä»£ç ä¸­ï¼Œä½ å¯ä»¥æŒ‡å®šæ•°æ®é›†çš„æ ¹ç›®å½•ã€æ•°æ®çš„å˜æ¢å’Œé¢„å¤„ç†æ–¹å¼
        self.data, self.slices = torch.load(self.processed_paths[0])

    @property
    def raw_file_names(self):
        # è¿”å›æœªç»å¤„ç†çš„åŸå§‹æ•°æ®æ–‡ä»¶ååˆ—è¡¨
        return ['some_file_1', 'some_file_2', ...]

    @property
    def processed_file_names(self):
        # è¿”å›å·²å¤„ç†çš„æ•°æ®æ–‡ä»¶ååˆ—è¡¨
        return ['data.pt']

    def download(self):
        # åœ¨æ­¤æ–¹æ³•ä¸­ï¼Œå®ç°ä»ç½‘ç»œä¸‹è½½æ•°æ®é›†çš„é€»è¾‘ï¼ˆå¦‚æœæœ¬åœ°æœ‰å¯ä»¥ä¸å®ç°è¿™ä¸ªï¼‰
        # Download to `self.raw_dir`.

    def process(self):
        # åœ¨æ­¤æ–¹æ³•ä¸­ï¼Œå®ç°æ•°æ®çš„å¤„ç†å’Œè½¬æ¢ä¸ºå›¾æ•°æ®å¯¹è±¡çš„é€»è¾‘
        # Read data into huge `Data` list.
        data_list = [...]

        if self.pre_filter is not None:
            data_list = [data for data in data_list if self.pre_filter(data)]

        if self.pre_transform is not None:
            data_list = [self.pre_transform(data) for data in data_list]

        data, slices = self.collate(data_list)
        torch.save((data, slices), self.processed_paths[0])

</code></pre>
<ul>
<li><code>raw_file_names()</code>è¿™ä¸ªå‡½æ•°ç»™å‡ºå¤šå¼ graphæ‰€å­˜çš„è·¯å¾„ï¼Œå‡è®¾æœ‰graph aï¼Œgraph bï¼Œé‚£ä¹ˆè¿™é‡Œreturnçš„å°±åº”å½“æ˜¯ä¸¤å¹…å›¾å¯¹åº”çš„æ–‡ä»¶åã€‚</li>
<li><code>processed_file_names()</code>å†™å¤„ç†æ‰€æœ‰graphè¿‡åæ‰€å­˜çš„è·¯å¾„ï¼Œé“ç†åŒraw_file_names</li>
<li><code>process()</code>å¤„ç†æ•°æ®ï¼Œæˆ<strong>è§„å®šæ ¼å¼</strong>ã€‚æ‰€è°“è§„å®šæ ¼å¼ï¼Œå°±æ˜¯<code>from torch_geometric.data import Data</code>è¿™ä¸ªDataç±»å‹ï¼Œå°±æ˜¯ä½ è¦å¤„ç†æˆçš„æ ¼å¼ã€‚</li>
<li><code>download()</code>å†™æ€ä¹ˆè·å¾—rawçš„datasetï¼Œæ˜¾ç„¶æˆ‘ä»¬è¦è‡ªå®šä¹‰æ•°æ®é›†ï¼Œå¾€å¾€æ˜¯åœ¨æœ¬åœ°å°±æœ‰çš„ï¼Œè¿™ä¸ªå¯ä»¥ç›´æ¥pass return</li>
</ul>
<ol start="2">
<li><strong>Datasetçš„å®ç°ï¼šæ¯”InMemoryDatasetå¤šå®ç°ä¸¤ä¸ªå‡½æ•°</strong></li>
</ol>
<pre><code class="language-python">from torch_geometric.data import Dataset

class MyCustomDataset(Dataset):
    def __init__(self, root, transform=None, pre_transform=None):
        super(MyOwnDataset, self).__init__(root, transform, pre_transform)
        # åœ¨æ­¤åˆå§‹åŒ–ä»£ç ä¸­ï¼Œä½ å¯ä»¥æŒ‡å®šæ•°æ®é›†çš„æ ¹ç›®å½•ã€æ•°æ®çš„å˜æ¢å’Œé¢„å¤„ç†æ–¹å¼
        self.data, self.slices = torch.load(self.processed_paths[0])

    @property
    def raw_file_names(self):
        # è¿”å›æœªç»å¤„ç†çš„åŸå§‹æ•°æ®æ–‡ä»¶ååˆ—è¡¨
        return ['some_file_1', 'some_file_2', ...]

    @property
    def processed_file_names(self):
        # è¿”å›å·²å¤„ç†çš„æ•°æ®æ–‡ä»¶ååˆ—è¡¨
        return ['data.pt']

    def download(self):
        # åœ¨æ­¤æ–¹æ³•ä¸­ï¼Œå®ç°ä»ç½‘ç»œä¸‹è½½æ•°æ®é›†çš„é€»è¾‘ï¼ˆå¦‚æœæœ¬åœ°æœ‰å¯ä»¥ä¸å®ç°è¿™ä¸ªï¼‰
        # Download to `self.raw_dir`.

    def process(self):
        # åœ¨æ­¤æ–¹æ³•ä¸­ï¼Œå®ç°æ•°æ®çš„å¤„ç†å’Œè½¬æ¢ä¸ºå›¾æ•°æ®å¯¹è±¡çš„é€»è¾‘
        # Read data into huge `Data` list.
        data_list = [...]

        if self.pre_filter is not None:
            data_list = [data for data in data_list if self.pre_filter(data)]

        if self.pre_transform is not None:
            data_list = [self.pre_transform(data) for data in data_list]

        data, slices = self.collate(data_list)
        torch.save((data, slices), self.processed_paths[0])
        
    #å¤šçš„ä¸¤ä¸ªå‡½æ•°
	def len(self):
        # è¿”å›æ•°æ®é›†ä¸­çš„å›¾æ•°é‡
        return len(self.processed_file_names)

    def get(self, idx):
        # è¿”å›æŒ‡å®šç´¢å¼•å¤„çš„å›¾æ•°æ®å¯¹è±¡
        data = torch.load(osp.join(self.processed_dir, 'data_{}.pt'.format(idx)))
        return data
</code></pre>
<p><strong>é¦–å…ˆ</strong>ä¼šåˆ¤æ–­ï¼Œåœ¨å‚æ•°rootè·¯å¾„ä¸‹å­˜ä¸å­˜åœ¨rawå’Œprocessedä¸¤ä¸ªè·¯å¾„ï¼Œrawä¸­å­˜ä¸å­˜åœ¨raw_pathsä¸­ç»™å‡ºçš„raw dataï¼Œå¦‚æœæ²¡æœ‰ï¼Œä»–ä¼šè°ƒç”¨down_loadå‡½æ•°ç»™ä½ ä¸‹è½½ã€‚æƒ³è¦ä¸è¿›è¡Œdownloadï¼Œé‚£ä¹ˆè¦ä¿è¯rawæ–‡ä»¶é‡Œä¸€å®šå­˜åœ¨ä½ raw pathé‡Œé¢è¿”å›çš„æ–‡ä»¶åã€‚</p>
<p>è¿™é‡Œä¸¾ä¸ªä¾‹å­ï¼š<br>
å‡è®¾æˆ‘è¦ä½¿ç”¨ç°æœ‰çš„AMinerè¿™ä¸ªæ•°æ®é›†ï¼Œä½†æ˜¯æ•°æ®æ˜¯dropboxçš„ï¼Œç½‘ä¸Šä¸äº†ã€‚æˆ‘è¦æ‰‹åŠ¨ä¸‹ä¸‹æ¥ä¹‹åä½¿ç”¨ã€‚<br>
é¦–å…ˆæˆ‘ç¡®å®šè¿™ä¸ªæ•°æ®é›†å­˜åœ¨å“ªé‡Œã€‚ç„¶åï¼Œåœ¨è¿™ä¸ªç›®å½•æ–°å»ºdir AMinerï¼Œåœ¨AMinerä¸‹é¢æ–°å»ºrawå’Œprocessedï¼Œå¦‚å›¾ï¼š</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/yushen611/img/raw/master/20210407161204577.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°" loading="lazy"></figure>
<p>ç„¶åè¿›å…¥æºç æŸ¥çœ‹æ‰€éœ€çš„rawæœ‰ä»€ä¹ˆï¼š</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/yushen611/img/raw/master/20210407161204577.png" alt="" loading="lazy"></figure>
<p>ç„¶åé€šè¿‡downloadå‡½æ•°ï¼Œæ‰¾åˆ°urlï¼Œä¸‹è½½ï¼ˆå¹¶è§£å‹ï¼‰åï¼Œå…¨éƒ¨æ”¾åˆ°rawé‚£ä¸ªç›®å½•é‡Œé¢ã€‚</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/yushen611/img/raw/master/20210407161422155.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°" loading="lazy"></figure>
<p><strong>æ³¨æ„ï¼šå¦‚æœæ²¡æœ‰å…¨éƒ¨æ”¾è¿›å»ï¼Œé‚£ä¹ˆä»£ç ä¼šæŠŠrawç›®å½•æ•´ä¸ªåˆ é™¤ï¼</strong><br>
æ¥ä¸‹æ¥çš„å°±å¯ä»¥ç›´æ¥ä½¿ç”¨äº†ï¼Œprocesså‡½æ•°ä¹Ÿä¼šæŠŠæ•°æ®å­˜å…¥processedï¼Œå¾€åä¸å†èµ˜è¿°ã€‚</p>
<ol start="3">
<li>ä»£ç ä¾‹å­</li>
</ol>
<ul>
<li>è‡ªå·±å®ç°çš„ä¾‹å­</li>
</ul>
<pre><code class="language-python">import torch
import pickle
from torch_geometric.data import InMemoryDataset, Data

class TCMDataSet(InMemoryDataset):
    def __init__(self,root,name,feature_size,transform=None,pre_transform=None):
        self.feature_size=feature_size
        print(f'feature size: {feature_size}')

        super(TCMDataSet, self).__init__(root, transform, pre_transform)
        self.data, self.slices = torch.load(self.processed_paths[0])

    @property
    def raw_file_names(self):
        return ['tcm_dataset.pt',]

    @property
    def processed_file_names(self):
        return ['tcm_dataset.pt',]

    def download(self):
        pass

    def process(self):

        # do processing, get x, y, edge_index ready.   

        graph=Data(x=features,edge_index=network.t().contiguous(),y=labels)
        train_idx = torch.tensor([id2inter_id[idx] for idx in herb_with_label_id], dtype=torch.long)
        #åŠ å…¥æ–°çš„å±æ€§
        graph.train_idx = train_idx

        if self.pre_filter is not None:
            graph = [data for data in graph if self.pre_filter(data)]

        if self.pre_transform is not None:
            graph = [self.pre_transform(data) for data in graph]

        data, slices = self.collate([graph])
        torch.save((data, slices), self.processed_paths[0])

</code></pre>
<ul>
<li>å®˜æ–¹æ–‡æ¡£çš„ä¾‹å­</li>
</ul>
<pre><code class="language-py">import os
import os.path as osp
import shutil
from typing import Callable, List, Optional

import torch

from torch_geometric.data import (
    Data,
    InMemoryDataset,
    download_url,
    extract_zip,
)
from torch_geometric.io import read_tu_data


[docs]class TUDataset(InMemoryDataset):
    r&quot;&quot;&quot;A variety of graph kernel benchmark datasets, *.e.g.*,
    :obj:`&quot;IMDB-BINARY&quot;`, :obj:`&quot;REDDIT-BINARY&quot;` or :obj:`&quot;PROTEINS&quot;`,
    collected from the `TU Dortmund University
    &lt;https://chrsmrrs.github.io/datasets&gt;`_.
    In addition, this dataset wrapper provides `cleaned dataset versions
    &lt;https://github.com/nd7141/graph_datasets&gt;`_ as motivated by the
    `&quot;Understanding Isomorphism Bias in Graph Data Sets&quot;
    &lt;https://arxiv.org/abs/1910.12091&gt;`_ paper, containing only non-isomorphic
    graphs.

    .. note::
        Some datasets may not come with any node labels.
        You can then either make use of the argument :obj:`use_node_attr`
        to load additional continuous node attributes (if present) or provide
        synthetic node features using transforms such as
        :class:`torch_geometric.transforms.Constant` or
        :class:`torch_geometric.transforms.OneHotDegree`.

    Args:
        root (str): Root directory where the dataset should be saved.
        name (str): The `name
            &lt;https://chrsmrrs.github.io/datasets/docs/datasets/&gt;`_ of the
            dataset.
        transform (callable, optional): A function/transform that takes in an
            :obj:`torch_geometric.data.Data` object and returns a transformed
            version. The data object will be transformed before every access.
            (default: :obj:`None`)
        pre_transform (callable, optional): A function/transform that takes in
            an :obj:`torch_geometric.data.Data` object and returns a
            transformed version. The data object will be transformed before
            being saved to disk. (default: :obj:`None`)
        pre_filter (callable, optional): A function that takes in an
            :obj:`torch_geometric.data.Data` object and returns a boolean
            value, indicating whether the data object should be included in the
            final dataset. (default: :obj:`None`)
        use_node_attr (bool, optional): If :obj:`True`, the dataset will
            contain additional continuous node attributes (if present).
            (default: :obj:`False`)
        use_edge_attr (bool, optional): If :obj:`True`, the dataset will
            contain additional continuous edge attributes (if present).
            (default: :obj:`False`)
        cleaned (bool, optional): If :obj:`True`, the dataset will
            contain only non-isomorphic graphs. (default: :obj:`False`)

    **STATS:**

    .. list-table::
        :widths: 20 10 10 10 10 10
        :header-rows: 1

        * - Name
          - #graphs
          - #nodes
          - #edges
          - #features
          - #classes
        * - MUTAG
          - 188
          - ~17.9
          - ~39.6
          - 7
          - 2
        * - ENZYMES
          - 600
          - ~32.6
          - ~124.3
          - 3
          - 6
        * - PROTEINS
          - 1,113
          - ~39.1
          - ~145.6
          - 3
          - 2
        * - COLLAB
          - 5,000
          - ~74.5
          - ~4914.4
          - 0
          - 3
        * - IMDB-BINARY
          - 1,000
          - ~19.8
          - ~193.1
          - 0
          - 2
        * - REDDIT-BINARY
          - 2,000
          - ~429.6
          - ~995.5
          - 0
          - 2
        * - ...
          -
          -
          -
          -
          -
    &quot;&quot;&quot;

    url = 'https://www.chrsmrrs.com/graphkerneldatasets'
    cleaned_url = ('https://raw.githubusercontent.com/nd7141/'
                   'graph_datasets/master/datasets')

    def __init__(self, root: str, name: str,
                 transform: Optional[Callable] = None,
                 pre_transform: Optional[Callable] = None,
                 pre_filter: Optional[Callable] = None,
                 use_node_attr: bool = False, use_edge_attr: bool = False,
                 cleaned: bool = False):
        self.name = name
        self.cleaned = cleaned
        super().__init__(root, transform, pre_transform, pre_filter)

        out = torch.load(self.processed_paths[0])
        if not isinstance(out, tuple) or len(out) != 3:
            raise RuntimeError(
                &quot;The 'data' object was created by an older version of PyG. &quot;
                &quot;If this error occurred while loading an already existing &quot;
                &quot;dataset, remove the 'processed/' directory in the dataset's &quot;
                &quot;root folder and try again.&quot;)
        data, self.slices, self.sizes = out
        self.data = Data.from_dict(data) if isinstance(data, dict) else data

        if self._data.x is not None and not use_node_attr:
            num_node_attributes = self.num_node_attributes
            self._data.x = self._data.x[:, num_node_attributes:]
        if self._data.edge_attr is not None and not use_edge_attr:
            num_edge_attrs = self.num_edge_attributes
            self._data.edge_attr = self._data.edge_attr[:, num_edge_attrs:]

    @property
    def raw_dir(self) -&gt; str:
        name = f'raw{&quot;_cleaned&quot; if self.cleaned else &quot;&quot;}'
        return osp.join(self.root, self.name, name)

    @property
    def processed_dir(self) -&gt; str:
        name = f'processed{&quot;_cleaned&quot; if self.cleaned else &quot;&quot;}'
        return osp.join(self.root, self.name, name)

    @property
    def num_node_labels(self) -&gt; int:
        return self.sizes['num_node_labels']

    @property
    def num_node_attributes(self) -&gt; int:
        return self.sizes['num_node_attributes']

    @property
    def num_edge_labels(self) -&gt; int:
        return self.sizes['num_edge_labels']

    @property
    def num_edge_attributes(self) -&gt; int:
        return self.sizes['num_edge_attributes']

    @property
    def raw_file_names(self) -&gt; List[str]:
        names = ['A', 'graph_indicator']
        return [f'{self.name}_{name}.txt' for name in names]

    @property
    def processed_file_names(self) -&gt; str:
        return 'data.pt'

    def download(self):
        url = self.cleaned_url if self.cleaned else self.url
        folder = osp.join(self.root, self.name)
        path = download_url(f'{url}/{self.name}.zip', folder)
        extract_zip(path, folder)
        os.unlink(path)
        shutil.rmtree(self.raw_dir)
        os.rename(osp.join(folder, self.name), self.raw_dir)

    def process(self):
        self.data, self.slices, sizes = read_tu_data(self.raw_dir, self.name)

        if self.pre_filter is not None or self.pre_transform is not None:
            data_list = [self.get(idx) for idx in range(len(self))]

            if self.pre_filter is not None:
                data_list = [d for d in data_list if self.pre_filter(d)]

            if self.pre_transform is not None:
                data_list = [self.pre_transform(d) for d in data_list]

            self.data, self.slices = self.collate(data_list)
            self._data_list = None  # Reset cache.

        torch.save((self._data.to_dict(), self.slices, sizes),
                   self.processed_paths[0])

    def __repr__(self) -&gt; str:
        return f'{self.name}({len(self)})'
</code></pre>
<h3 id="datasetçš„æ‰“ä¹±ä¸åˆ’åˆ†">datasetçš„æ‰“ä¹±ä¸åˆ’åˆ†</h3>
<p>æ‰“ä¹±æ•°æ®é›†</p>
<pre><code class="language-python"># æ–¹æ³•1
dataset = dataset.shuffle()
&gt;&gt;&gt; ENZYMES(600)
# æ–¹æ³•2 ï¼ˆä¸¤ç§æ–¹æ³•ç­‰ä»·ï¼‰
perm = torch.randperm(len(dataset))
dataset = dataset[perm]
&gt;&gt; ENZYMES(600)
</code></pre>
<p>æ•°æ®é›†çš„åˆ’åˆ†</p>
<pre><code class="language-python">train_dataset = dataset[:540]
&gt;&gt;&gt; ENZYMES(540)

test_dataset = dataset[540:]
&gt;&gt;&gt; ENZYMES(60)
</code></pre>
<h2 id="torch_geometricloaderdataloader">torch_geometric.loader.DataLoader</h2>
<p><code>torch_geometric.loader.DataLoader</code> æ˜¯ PyTorch Geometric ä¸­ç”¨äºåŠ è½½å›¾æ•°æ®çš„æ•°æ®åŠ è½½å™¨ã€‚å®ƒå¯ä»¥å¸®åŠ©ä½ æœ‰æ•ˆåœ°å°†å›¾æ•°æ®è½¬æ¢æˆæ‰¹é‡æ•°æ®ï¼Œç”¨äºæ¨¡å‹çš„è®­ç»ƒã€éªŒè¯å’Œæµ‹è¯•ã€‚</p>
<p><code>torch_geometric.data.Batch</code>ç»§æ‰¿è‡ª<code>torch_geometric.data.Data</code>ï¼Œå¹¶ä¸”å¤šäº†ä¸€ä¸ªå±æ€§ï¼š<code>batch</code>ã€‚</p>
<p><code>batch</code> å±æ€§<strong>å®é™…ä¸Šæ˜¯ä¸€ä¸ªæ•´æ•°åˆ—å‘é‡</strong>ï¼Œå…¶ä¸­çš„æ¯ä¸ªå…ƒç´ å¯¹åº”äºæ‰¹æ¬¡ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹æˆ–è¾¹æ‰€å±çš„å›¾æ‰¹æ¬¡ç¼–å·ã€‚</p>
<p><code>batch</code> is a column vector which maps each node to its respective graph in the batch:</p>
<p>â€‹				<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>=</mo><msup><mrow><mo>[</mo><mn>0</mn><mtext>Â </mtext><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mtext>Â </mtext><mn>0</mn><mtext>Â </mtext><mn>1</mn><mtext>Â </mtext><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mtext>Â </mtext><mi>n</mi><mo>âˆ’</mo><mn>2</mn><mtext>Â </mtext><mi>n</mi><mo>âˆ’</mo><mn>1...</mn><mi>n</mi><mo>âˆ’</mo><mn>1</mn><mo>]</mo></mrow><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">batch = {[0\  ...\  0 \ 1 \ ... \ n-2 \ n-1 ... n-1]}^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.231231em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mopen">[</span><span class="mord">0</span><span class="mspace">Â </span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace">Â </span><span class="mord">0</span><span class="mspace">Â </span><span class="mord">1</span><span class="mspace">Â </span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace">Â </span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">âˆ’</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mspace">Â </span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">âˆ’</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">âˆ’</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></p>
<p>å®é™…ä½¿ç”¨çš„æ—¶å€™ï¼Œç›´æ¥<code>x=batch.x</code>,<code>y=batch.y</code>,<code>edge_index = batch.edge_index</code>ï¼ŒæŠŠ<code>batch</code>å½“ä½œ<code>data</code>ç”¨å°±è¡Œäº†</p>
<p>å¦‚æœéœ€è¦<strong>å¯¹å›¾è¿›è¡Œç‰¹å¾çš„èšåˆ</strong>æ—¶ï¼Œå¯ä»¥å¦‚ä¸‹ä½¿ç”¨</p>
<blockquote>
<p>ç‰¹å¾çš„èšåˆæ“ä½œåœ¨å›¾ç¥ç»ç½‘ç»œçš„æ¨¡å‹ä¸­æ˜¯éœ€è¦çš„ï¼Œä½†é€šå¸¸åœ¨æ¨¡å‹çš„å‰å‘ä¼ æ’­è¿‡ç¨‹ä¸­è‡ªåŠ¨å¤„ç†ã€‚ä½ åœ¨ä»£ç ä¸­æ‰‹åŠ¨è¿›è¡Œçš„ç‰¹å¾èšåˆæ“ä½œå¯èƒ½æ˜¯ä¸ºäº†æ•°æ®é¢„å¤„ç†æˆ–è€…ç‰¹å®šçš„å®éªŒéœ€è¦ã€‚</p>
</blockquote>
<pre><code class="language-python">from torch_scatter import scatter_mean
from torch_geometric.datasets import TUDataset
from torch_geometric.data import DataLoader

dataset = TUDataset(root='/tmp/ENZYMES', name='ENZYMES', use_node_attr=True)
loader = DataLoader(dataset, batch_size=32, shuffle=True)

for data in loader:
    data
    #data: Batch(batch=[1082], edge_index=[2, 4066], x=[1082, 21], y=[32])

    x = scatter_mean(data.x, data.batch, dim=0)
    # x.size(): torch.Size([32, 21])
</code></pre>
<blockquote>
<p>åœ¨å›¾ç¥ç»ç½‘ç»œä¸­ï¼ŒèŠ‚ç‚¹ç‰¹å¾é€šå¸¸æ˜¯èŠ‚ç‚¹çš„å±æ€§æˆ–ç‰¹å¾å‘é‡ã€‚å½“ä½ æœ‰ä¸€ä¸ªåŒ…å«å¤šä¸ªå›¾æ•°æ®çš„æ‰¹æ¬¡æ—¶ï¼Œæ¯ä¸ªå›¾æ•°æ®ä¸­çš„èŠ‚ç‚¹æ•°å¯èƒ½ä¸åŒã€‚ç„¶è€Œï¼Œæ¨¡å‹éœ€è¦æ¯ä¸ªå›¾çš„ä¸€ä¸ªå›ºå®šå¤§å°çš„è¡¨ç¤ºã€‚</p>
<p>ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œé€šå¸¸ä¼šè¿›è¡Œç‰¹å¾èšåˆæ“ä½œï¼Œå°†æ¯ä¸ªå›¾ä¸­çš„èŠ‚ç‚¹ç‰¹å¾èšåˆæˆä¸€ä¸ªå›¾çº§åˆ«çš„ç‰¹å¾ã€‚åœ¨ä½ çš„ä»£ç ä¸­ï¼Œ<code>scatter</code> å‡½æ•°ç”¨äºè¿›è¡Œè¿™ç§ç‰¹å¾èšåˆæ“ä½œã€‚</p>
<ul>
<li><code>data.x</code> æ˜¯å›¾æ‰¹æ¬¡ä¸­æ‰€æœ‰èŠ‚ç‚¹çš„ç‰¹å¾çŸ©é˜µï¼Œå¤§å°ä¸º <code>[æ€»èŠ‚ç‚¹æ•°, ç‰¹å¾ç»´åº¦]</code>ã€‚</li>
<li><code>data.batch</code> æ˜¯ä¸€ä¸ªåŒ…å«æ¯ä¸ªèŠ‚ç‚¹æ‰€å±å›¾æ‰¹æ¬¡ç´¢å¼•çš„å¼ é‡ï¼Œå¤§å°ä¸º <code>[æ€»èŠ‚ç‚¹æ•°]</code>ã€‚å®ƒç”¨äºæ ‡è¯†æ¯ä¸ªèŠ‚ç‚¹å±äºå“ªä¸ªå›¾æ‰¹æ¬¡ã€‚</li>
<li><code>dim=0</code> è¡¨ç¤ºåœ¨ç¬¬ä¸€ä¸ªç»´åº¦ä¸Šè¿›è¡Œèšåˆï¼Œä¹Ÿå°±æ˜¯æŒ‰ç…§ä¸åŒçš„å›¾æ‰¹æ¬¡è¿›è¡Œèšåˆã€‚</li>
<li><code>reduce='mean'</code> è¡¨ç¤ºé‡‡ç”¨å¹³å‡å€¼è¿›è¡Œèšåˆæ“ä½œã€‚</li>
</ul>
<p>å› æ­¤ï¼Œ<code>x = scatter(data.x, data.batch, dim=0, reduce='mean')</code> è¿™è¡Œä»£ç çš„ä½œç”¨æ˜¯å°†æ¯ä¸ªå›¾æ‰¹æ¬¡ä¸­çš„èŠ‚ç‚¹ç‰¹å¾æŒ‰ç…§å¹³å‡å€¼è¿›è¡Œèšåˆï¼Œç”Ÿæˆä¸€ä¸ªå›¾çº§åˆ«çš„ç‰¹å¾è¡¨ç¤ºã€‚è¿™æ ·ï¼Œæ¯ä¸ªå›¾æ•°æ®éƒ½æœ‰ä¸€ä¸ªå›ºå®šå¤§å°çš„ç‰¹å¾å‘é‡ï¼Œå¯ä»¥è¾“å…¥åˆ°å›¾ç¥ç»ç½‘ç»œä¸­è¿›è¡Œåç»­çš„å›¾çº§åˆ«è®¡ç®—ã€‚</p>
<p>æœ€ç»ˆï¼Œ<code>x</code> çš„å¤§å°ä¸º <code>[å›¾æ‰¹æ¬¡æ•°é‡, ç‰¹å¾ç»´åº¦]</code>ï¼Œå…¶ä¸­å›¾æ‰¹æ¬¡æ•°é‡ä¸º 32ï¼ˆå³ä½ çš„æ‰¹æ¬¡å¤§å°ï¼‰ï¼Œç‰¹å¾ç»´åº¦ä¸º 21ã€‚è¿™å°±æ˜¯æ¯ä¸ªå›¾æ•°æ®ç»è¿‡ç‰¹å¾èšåˆåçš„å›¾çº§åˆ«ç‰¹å¾è¡¨ç¤ºã€‚</p>
</blockquote>
<h3 id="dataloaderä½¿ç”¨å®ä¾‹">DataLoaderä½¿ç”¨å®ä¾‹</h3>
<pre><code class="language-python">import torch
import torch.optim as optim
import torch.nn.functional as F
from torch_geometric.loader import DataLoader

# å‡è®¾ dataset æ˜¯ä¸€ä¸ªåŒ…å«å›¾æ•°æ®çš„æ•°æ®é›†å¯¹è±¡
dataset = ...

# åˆ›å»º DataLoader å®ä¾‹
batch_size = 64
dataloader = DataLoader(dataset, batch_size=batch_size, shuffle=True)

# å®šä¹‰æŸå¤±å‡½æ•°
loss_fn = torch.nn.CrossEntropyLoss()
# å®šä¹‰ä¼˜åŒ–å™¨
optimizer = optim.Adam(model.parameters(), lr=0.01)

# è®¾ç½®æ¨¡å‹ä¸ºè®­ç»ƒæ¨¡å¼
model.train()
# åœ¨è®­ç»ƒå¾ªç¯ä¸­ä½¿ç”¨ DataLoader
for batch in dataloader:
    
    batch# &gt;&gt;&gt; DataBatch(batch=[1082], edge_index=[2, 4066], x=[1082, 21], y=[32])
    batch.num_graphs# &gt;&gt;&gt; 32
    # åœ¨è¿™é‡Œæ‰§è¡Œæ¨¡å‹çš„å‰å‘ä¼ æ’­ã€æŸå¤±è®¡ç®—ã€åå‘ä¼ æ’­ç­‰æ“ä½œ
    optimizer.zero_grad()  # æ¢¯åº¦å½’é›¶

    # è·å–æ‰¹æ¬¡çš„æ•°æ®
    x = batch.x
    edge_index = batch.edge_index
    y = batch.y
    # è¿˜æœ‰batch.num_graphs

    # è¿›è¡Œæ¨¡å‹çš„å‰å‘ä¼ æ’­
    output = model(x, edge_index)

    # è®¡ç®—æŸå¤±
    loss = loss_fn(output, y)

    # åå‘ä¼ æ’­å’Œå‚æ•°æ›´æ–°
    loss.backward()
    optimizer.step()

    # æ‰“å°æŸå¤±
    print(&quot;Batch Loss:&quot;, loss.item())
</code></pre>
<p><code>torch_geometric.loader.DataLoader</code>ä¸ <code>torch.utils.data.DataLoader</code>çš„ä¸åŒ</p>
<blockquote>
<ul>
<li><code>torch_geometric.loader.DataLoader</code>ï¼šä¸“é—¨å¤„ç†å›¾æ•°æ®å¯¹è±¡ï¼Œå¯ä»¥å°†å›¾æ•°æ®æœ‰æ•ˆåœ°ç»„ç»‡æˆæ‰¹æ¬¡ï¼ŒåŒæ—¶æä¾›äº†å¯¹å›¾æ•°æ®é¢„å¤„ç†ã€è½¬æ¢å’Œå¢å¼ºçš„æ”¯æŒã€‚</li>
<li><code>torch.utils.data.DataLoader</code>ï¼šä¸»è¦å¤„ç†ä¼ ç»Ÿæ•°æ®ï¼Œä¸æä¾›å›¾æ•°æ®çš„ç‰¹æ®Šæ”¯æŒã€‚</li>
</ul>
</blockquote>
<h1 id="æ¨¡å‹åŸºç¡€è®­ç»ƒå®ä¾‹">æ¨¡å‹åŸºç¡€è®­ç»ƒå®ä¾‹</h1>
<h2 id="node-classify">node classify</h2>
<h3 id="step1ç¯å¢ƒä»£ç é…ç½®">step1:ç¯å¢ƒä»£ç é…ç½®</h3>
<pre><code class="language-python">## æ£€æŸ¥torchç‰ˆæœ¬ä»¥åŠæ ¹æ®cudaç¡®è®¤device
import os
import torch
os.environ['TORCH'] = torch.__version__
print(torch.__version__)

use_cuda_if_available = True
device = torch.device('cuda' if torch.cuda.is_available() and use_cuda_if_available else 'cpu')
print(device)
</code></pre>
<pre><code class="language-python"># ä¸‹è½½åº“
!pip install -q torch-scatter -f https://data.pyg.org/whl/torch-${TORCH}.html
!pip install -q torch-sparse -f https://data.pyg.org/whl/torch-${TORCH}.html
!pip install -q git+https://github.com/pyg-team/pytorch_geometric.git
</code></pre>
<h3 id="step2æ•°æ®é›†åŠ è½½">step2:æ•°æ®é›†åŠ è½½</h3>
<pre><code class="language-python"># å¯¼å…¥ä¾èµ–
import torch_geometric
from torch_geometric.datasets import Planetoid
</code></pre>
<pre><code class="language-python">#å¯¼å…¥æ•°æ®é›†
dataset = Planetoid(root=&quot;tutorial1&quot;,name= &quot;Cora&quot;)
</code></pre>
<pre><code class="language-python"># æ£€æŸ¥datasetçš„å±æ€§ï¼šdatasetä¸­&lt;å›¾çš„æ•°é‡&gt;ã€&lt;åˆ†ç±»çš„æ•°é‡&gt;ã€&lt;èŠ‚ç‚¹çš„ç‰¹å¾ç»´åº¦&gt;ã€&lt;è¾¹çš„ç‰¹å¾ç»´åº¦&gt;
print(dataset)  # Cora()
print(&quot;number of graphs:\t\t&quot;,len(dataset)) # number of graphs:		 1
print(&quot;number of classes:\t\t&quot;,dataset.num_classes)# number of classes:		 7
print(&quot;number of node features:\t&quot;,dataset.num_node_features)# number of node features:	 1433
print(&quot;number of edge features:\t&quot;,dataset.num_edge_features)# number of edge features:	 0
</code></pre>
<pre><code class="language-python">#æ£€æŸ¥dataçš„å±æ€§ï¼šå›¾çš„å¿…å¤‡å±æ€§[edge_indexè¾¹çš„å¤§å°ï¼ŒèŠ‚ç‚¹ç‰¹å¾å‘é‡xçš„å¤§å°]ï¼Œå…¶ä»–å±æ€§ï¼š[yçš„å¤§å°ï¼Œtrain_mask]
print(dataset.data) # Data(x=[2708, 1433], edge_index=[2, 10556], y=[2708], train_mask=[2708], val_mask=[2708], test_mask=[2708])
print(&quot;edge_index:\t\t&quot;,dataset.data.edge_index.shape)
print(dataset.data.edge_index)
print(&quot;\n&quot;)
print(&quot;train_mask:\t\t&quot;,dataset.data.train_mask.shape)
print(dataset.data.train_mask)
print(&quot;\n&quot;)
print(&quot;x:\t\t&quot;,dataset.data.x.shape)
print(dataset.data.x)
print(&quot;\n&quot;)
print(&quot;y:\t\t&quot;,dataset.data.y.shape)
print(dataset.data.y)
</code></pre>
<h3 id="step3å†™æ¨¡å‹ç»“æ„ä»£ç ">step3:å†™æ¨¡å‹ç»“æ„ä»£ç </h3>
<pre><code class="language-python">import torch
import torch.nn.functional as F
from torch_geometric.nn import SAGEConv
</code></pre>
<pre><code class="language-python">class Net(torch.nn.Module):
    def __init__(self):
        super(Net, self).__init__()
        
        self.conv = SAGEConv(dataset.num_features,
                             dataset.num_classes,
                             aggr=&quot;max&quot;) # max, mean, add ...)

    def forward(self):
        x = self.conv(data.x, data.edge_index)
        return F.log_softmax(x, dim=1)
</code></pre>
<h3 id="step4å†™è®­ç»ƒçš„å‰ç½®ä»£ç ">step4:å†™è®­ç»ƒçš„å‰ç½®ä»£ç </h3>
<pre><code class="language-python"># å®šä¹‰æ¨¡å‹å¯¹è±¡ï¼Œä¼˜åŒ–å™¨å¯¹è±¡ï¼ŒæŸå¤±å‡½æ•°
model = Net().to(device)
optimizer = torch.optim.Adam(model.parameters(), lr=0.01, weight_decay=5e-4)
loss_fn = torch.nn.NLLLoss()
</code></pre>
<ul>
<li>æŸå¤±å‡½æ•°è¯´æ˜ï¼š<code>torch.nn.NLLLoss()</code> VS <code>torch.nn.CrossEntropyLoss()</code></li>
</ul>
<blockquote>
<p>ç»“è®ºï¼šç›´æ¥ç”¨nn.CrossEntropyå’Œnn.LogSoftmax+nn.NLLLossæ˜¯ä¸€æ ·çš„ç»“æœ</p>
<pre><code class="language-python">import torch
import torch.nn as nn
 
a = torch.Tensor([[1,2,3]])
target = torch.Tensor([2]).long()
logsoftmax = nn.LogSoftmax()
ce = nn.CrossEntropyLoss()
nll = nn.NLLLoss()
 
# æµ‹è¯•CrossEntropyLoss
cel = ce(a,target)
print(cel)
# è¾“å‡ºï¼štensor(0.4076)
 
# æµ‹è¯•LogSoftmax+NLLLoss
lsm_a = logsoftmax(a)
nll_lsm_a = nll(lsm_a,target)
# è¾“å‡ºtensor(0.4076)
</code></pre>
<p>è¿™ä¸¤ä¸ªæŸå¤±å‡½æ•°éƒ½æ˜¯ç”¨äºå¤šåˆ†ç±»ä»»åŠ¡çš„ï¼Œå¦‚æœæœ€åè¾“å‡ºæ˜¯softmaxå±‚ï¼Œå°±è¦ç”¨NLLLossäº†</p>
<p>[å‚è€ƒåšå®¢link](<a href="https://blog.csdn.net/weixin_43593330/article/details/113505657">torch.nn.NLLLoss()ä¸torch.nn.CrossEntropyLoss()_torch.nn.nllloss weight_æˆ‘æ˜¯å¤©æ‰å¾ˆå¥½çš„åšå®¢-CSDNåšå®¢</a>)</p>
</blockquote>
<pre><code class="language-python"># å®šä¹‰ç”¨äºè®­ç»ƒçš„trainå‡½æ•°ï¼Œä»¥åŠç”¨äºæµ‹è¯•çš„testå‡½æ•°
def train():
    model.train()
    optimizer.zero_grad()
    logits = model()
    loss = loss_fn(logits[data.train_mask], data.y[data.train_mask])
    loss.backward()
    optimizer.step()

def test():
    model.eval()
    logits, accs = model(), []
    for _, mask in data('train_mask', 'val_mask', 'test_mask'):
        pred = logits[mask].max(1)[1]
        acc = pred.eq(data.y[mask]).sum().item() / mask.sum().item()
        accs.append(acc)
    return accs

</code></pre>
<blockquote>
<p>è¯´æ˜</p>
<ol>
<li><code>model()</code>:æ‰§è¡Œ <code>model()</code> æ—¶ï¼Œå®é™…ä¸Šæ˜¯åœ¨è°ƒç”¨æ¨¡å‹å¯¹è±¡çš„ <code>forward</code> æ–¹æ³•ã€‚è¿™å°†è§¦å‘æ¨¡å‹å¯¹è¾“å…¥æ•°æ®çš„è®¡ç®—å’Œè½¬æ¢ï¼Œæœ€ç»ˆå¾—åˆ°æ¨¡å‹çš„è¾“å‡ºï¼ˆä¹Ÿç§°ä¸ºé¢„æµ‹ç»“æœæˆ–logitsï¼‰</li>
<li><code>logits</code>:é€šå¸¸æŒ‡ä»£æ¨¡å‹åœ¨å¤šç±»åˆ«åˆ†ç±»é—®é¢˜ä¸­ï¼Œå„ä¸ªç±»åˆ«çš„åˆ†æ•°æˆ–åŸå§‹è¾“å‡º,<strong>è¡¨ç¤ºæ¨¡å‹åœ¨æ²¡æœ‰ç»è¿‡æ¿€æ´»å‡½æ•°å¤„ç†ä¹‹å‰çš„åŸå§‹è¾“å‡ºå€¼</strong>ã€‚è¿™äº›åˆ†æ•°å¯ä»¥é€šè¿‡ softmax å‡½æ•°è¿›è¡Œå½’ä¸€åŒ–ï¼Œå¾—åˆ°æ¯ä¸ªç±»åˆ«çš„æ¦‚ç‡ã€‚åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œ&quot;logits&quot; ä¹Ÿå¯èƒ½æŒ‡ä»£å›å½’é—®é¢˜ä¸­æ¨¡å‹çš„åŸå§‹è¾“å‡ºã€‚</li>
</ol>
</blockquote>
<h3 id="step5è®­ç»ƒæ¨¡å‹å¹¶è®°å½•">step5:è®­ç»ƒæ¨¡å‹å¹¶è®°å½•</h3>
<pre><code class="language-python">best_val_acc = test_acc = 0
for epoch in range(1,100):
    train()
    _, val_acc, tmp_test_acc = test()
    if val_acc &gt; best_val_acc:
        best_val_acc = val_acc
        test_acc = tmp_test_acc
    log = 'Epoch: {:03d}, Val: {:.4f}, Test: {:.4f}'
    
    if epoch % 10 == 0:
        print(log.format(epoch, best_val_acc, test_acc))
</code></pre>
<h3 id="ste6ä¿å­˜åŠ è½½æ¨¡å‹å¹¶é¢„æµ‹">ste6:ä¿å­˜,åŠ è½½æ¨¡å‹å¹¶é¢„æµ‹</h3>
<p>ä¿å­˜æ¨¡å‹</p>
<pre><code class="language-python">import torch

# å‡è®¾ä½ çš„æ¨¡å‹æ˜¯ä¸€ä¸ª PyTorch æ¨¡å‹å®ä¾‹ï¼Œä¾‹å¦‚ model = Net()
# model çš„ç»“æ„å’Œå‚æ•°ä¼šè¢«ä¿å­˜åˆ°æŒ‡å®šçš„æ–‡ä»¶
torch.save(model.state_dict(), 'model.pth')
</code></pre>
<p>åŠ è½½æ¨¡å‹</p>
<pre><code class="language-python">import torch
from your_model_module import Net  # å¯¼å…¥ä½ çš„æ¨¡å‹ç±»

# åˆ›å»ºæ¨¡å‹å®ä¾‹
model = Net()

# åŠ è½½ä¹‹å‰ä¿å­˜çš„æ¨¡å‹å‚æ•°
model.load_state_dict(torch.load('model.pth'))

# å°†æ¨¡å‹è®¾ç½®ä¸ºè¯„ä¼°æ¨¡å¼ï¼ˆå¦‚æœæ˜¯ç”¨äºæ¨ç†ï¼‰
model.eval()

</code></pre>
<p>é¢„æµ‹</p>
<pre><code class="language-python"># å‡†å¤‡è¾“å…¥æ•°æ®
x, edge_index = data.x.to(device), data.edge_index.to(device) # deviceä¸€èˆ¬ä¸º'cuda'æˆ–'cpu'

# è¿›è¡Œé¢„æµ‹
with torch.no_grad():
    output = model(x, edge_index) # è¿™é‡Œéœ€è¦çœ‹å…·ä½“forward()å‡½æ•°æ€ä¹ˆå®šä¹‰çš„
    predictions = output.argmax(dim=1)

# å°†ç»“æœç§»åŠ¨å› CPUï¼Œå¦‚æœéœ€è¦
predictions = predictions.cpu()

# æ‰“å°é¢„æµ‹ç»“æœ
print(predictions)
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#datadatasetdateloader">data,dataset,dateloader</a>
<ul>
<li><a href="#torch_geometricdatadata%E8%A1%A8%E7%A4%BA%E5%9B%BE">torch_geometric.data.Dataï¼šè¡¨ç¤ºå›¾</a>
<ul>
<li><a href="#data%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9E%84%E5%BB%BA%E6%96%B9%E5%BC%8F">Dataçš„ä¸¤ç§æ„å»ºæ–¹å¼</a></li>
<li><a href="#data%E7%9A%84%E5%B1%9E%E6%80%A7">Dataçš„å±æ€§</a></li>
<li><a href="#data%E7%9A%84%E5%85%B6%E4%BB%96%E7%94%A8%E6%B3%95">Dataçš„å…¶ä»–ç”¨æ³•</a></li>
</ul>
</li>
<li><a href="#torch_geometricdatasets">torch_geometric.datasets</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B8%A6%E6%95%B0%E6%8D%AE%E9%9B%86">ä½¿ç”¨è‡ªå¸¦æ•°æ®é›†</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86">åˆ›å»ºä¸€ä¸ªè‡ªå·±çš„æ•°æ®é›†</a></li>
<li><a href="#dataset%E7%9A%84%E6%89%93%E4%B9%B1%E4%B8%8E%E5%88%92%E5%88%86">datasetçš„æ‰“ä¹±ä¸åˆ’åˆ†</a></li>
</ul>
</li>
<li><a href="#torch_geometricloaderdataloader">torch_geometric.loader.DataLoader</a>
<ul>
<li><a href="#dataloader%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B">DataLoaderä½¿ç”¨å®ä¾‹</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83%E5%AE%9E%E4%BE%8B">æ¨¡å‹åŸºç¡€è®­ç»ƒå®ä¾‹</a>
<ul>
<li><a href="#node-classify">node classify</a>
<ul>
<li><a href="#step1%E7%8E%AF%E5%A2%83%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE">step1:ç¯å¢ƒä»£ç é…ç½®</a></li>
<li><a href="#step2%E6%95%B0%E6%8D%AE%E9%9B%86%E5%8A%A0%E8%BD%BD">step2:æ•°æ®é›†åŠ è½½</a></li>
<li><a href="#step3%E5%86%99%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81">step3:å†™æ¨¡å‹ç»“æ„ä»£ç </a></li>
<li><a href="#step4%E5%86%99%E8%AE%AD%E7%BB%83%E7%9A%84%E5%89%8D%E7%BD%AE%E4%BB%A3%E7%A0%81">step4:å†™è®­ç»ƒçš„å‰ç½®ä»£ç </a></li>
<li><a href="#step5%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E5%B9%B6%E8%AE%B0%E5%BD%95">step5:è®­ç»ƒæ¨¡å‹å¹¶è®°å½•</a></li>
<li><a href="#ste6%E4%BF%9D%E5%AD%98%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B%E5%B9%B6%E9%A2%84%E6%B5%8B">ste6:ä¿å­˜,åŠ è½½æ¨¡å‹å¹¶é¢„æµ‹</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '2c8e752d0e362a2a873f',
    clientSecret: '862c97459ff5f1f34a4ff6ce3442f41a00c107e0',
    repo: 'yushen611.github.io',
    owner: 'yushen611',
    admin: ['yushen611'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://yushen611.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
